<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>XML::LibXML</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><meta name="description" content="XML::LibXML es uno de los más potentes procesadores XML para Perl. Es un interfaz a la librería libxml2 de Gnome. Éste es un análisis del módulo y sus usos."><meta name="keywords" content="Perl, XML, libxml2, XML::LibXML, xs, Walsh"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="id2408114"></a>XML::LibXML</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Carlos</span> <span class="surname">Escribano</span></h3></div></div><div><div class="legalnotice"><a name="id2431613"></a><p class="legalnotice-title"><b>DC.Rights</b></p><p><a href="http://opencontent.org/openpub/" target="_top">OpenPublication</a></p></div></div><div></div><div></div></div><hr></div><p><a href="http://search.cpan.org/perldoc?XML::LibXML" target="_top"><code class="classname">XML::LibXML</code></a> es uno de los mejores procesadores XML disponibles en Perl. Su potencia y rapidez se deben a que es un interfaz de la librería XML de <a href="http://www.gnome.org" target="_top">Gnome</a>, escrita en C,  <a href="http://xmlsoft.org/" target="_top">libxml2</a>. Seguramente es el camino más rápido y eficiente de tratar documentos XML en Perl al modo <a href="http://www.w3.org/DOM/" target="_top">DOM</a>, sobre todo si se trata de documentos extensos y complejos.</p><p>Constituye uno de los tres procesadores XML <span class="emphasis"><em>mayores</em></span> de Perl, los que proveen de los conjuntos de funcionalidades más completos, junto con <a href="http://search.cpan.org/perldoc?XML::GDOME" target="_top"><code class="classname">XML::GDOME</code></a>, interfaz de la librería <a href="http://gdome2.cs.unibo.it/" target="_top">Gdome</a>, a su vez basada en libxml2 y <a href="http://search.cpan.org/perldoc?XML::Xerces" target="_top"><code class="classname">XML::Xerces</code></a>, que da acceso desde Perl a la librería <a href="http://xml.apache.org/xerces-c/" target="_top">Xerces C++</a>.</p><p>Entre sus muchas ventajas podemos destacar:</p><div class="itemizedlist"><ul type="disc"><li><p>El soporte de XML es bastante completo:  Entre otros, <a href="http://www.w3.org/TR/xptr" target="_top">Xpointer</a>,  <a href="http://www.w3.org/TR/xinclude/" target="_top">Xinclude</a>,  <a href="http://www.w3.org/TR/xpath" target="_top">Xpath</a> (1.0), <a href="http://www.w3.org/TR/xml-id/" target="_top">xml:id</a>, <a href="http://www.oasis-open.org/committees/entity/spec-2001-08-06.html" target="_top">Catálogos</a>, y validaciones contra <a href="http://www.oasis-open.org/committees/relax-ng/spec-20011203.html" target="_top">RelaxNG</a> y <a href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/" target="_top">esquemas XML</a>.</p></li><li><p>Permite procesar también documentos HTML y DTDs. Tiene asímismo un soporte parcial de SGML, y en concreto para <a href="http://www.oasis-open.org/docbook/sgml/" target="_top">Docbook SGML</a>, sin validación, pero esta función ha sido declarada obsoleta.</p></li><li><p>Soporta cualquier tipo de URI en enlaces Xinclude y entidades externas. Las uris que se refieren al sistema de ficheros, las de HTML y FTP son reconocidas de forma nativa, incorporando clientes de estos protocolos para su utilización transparente; se provee además de un mecanismo para soportar cualquier otro tipo de uri.</p></li><li><p>Permite utilizar archivos incompletos o con errores.</p></li><li><p>Se puede utilizar un amplio abanico de medios de entrada: archivos, cadenas de caracteres o filehandles. Estos últimos permiten encadenarlo con otros procesos del sistema</p></li><li><p>Admite documentos comprimidos con gzip, y puede en consonancia producir en la salida textos igualmente comprimidos.</p></li><li><p>Permite el procesado <a href="http://www.w3.org/DOM/" target="_top">DOM</a> y <a href="http://perl-xml.sourceforge.net/perl-sax/" target="_top">SAX</a>.</p></li></ul></div><p><code class="classname">XML::LibXML</code> es la base de un buen número de módulos de <a href="http://www.cpan.org" target="_top">CPAN</a>, que lo utilizan para extraer y manipular datos concretos. Además, sobre <code class="classname">XML::LibXML</code> se han establecido algunos módulos de uso de DOM de manera no estándard, buscando facilidades de uso, como  <a href="http://search.cpan.org/perldoc?XML::LibXML::Tools" target="_top"><code class="classname">XML::LibXML::Tools</code></a> y <a href="http://search.cpan.org/perldoc?XML::SimpleObject::LibXML" target="_top"><code class="classname">XML::SimpleObject::LibXML</code></a>. Un módulo adicional, <a href="http://search.cpan.org/perldoc?Template::Plugin::XML::LibXML" target="_top"><code class="classname">Template::Plugin::XML::LibXML</code></a> permite la creación de plantillas para el uso de <code class="classname">XML::LibXML</code>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2408297"></a>Las clases de XML::LibXML</h2></div></div></div><p>La distribución de <a href="http://search.cpan.org/perldoc?XML::LibXML" target="_top">XML::LibXML</a> (1.58) provee de 24 clases, para el procesamiento (DOM y SAX) y la utilización del árbol  DOM.</p><div class="itemizedlist"><ul type="disc"><li><p><b>Procesadores DOM. </b></p><p><a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Parser.pod" target="_top"><code class="classname">XML::LibXML</code></a> realiza el procesado DOM normal para documentos XML, HTML y SGML. Tres procesadores adicionales están disponibles para documentos de definiciones de datos: <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Dtd.pod" target="_top"><code class="classname">XML::LibXML::Dtd</code></a>, de DTDs;  <code class="classname">XML::LibXML::RelaxNG</code><sup>[<a name="id2408349" href="#ftn.id2408349">1</a>]</sup>, para esquemas RelaxNG; <code class="classname">XML::LibXML::Schema</code><sup>[<a name="id2408358" href="#ftn.id2408358">2</a>]</sup>, para esquemas XML.</p></li><li><p><b>Procesadores SAX. </b></p><p><a href="http://search.cpan.org/perldoc?XML::LibXML::SAX" target="_top"><code class="classname">XML::LibXML::SAX</code></a>.</p></li><li><p><b>Generadores SAX. </b></p><p><code class="classname">XML::LibXML::SAX::Parser</code><sup>[<a name="id2408390" href="#ftn.id2408390">3</a>]</sup>, generador de eventos SAX desde DOM, y <a href="http://search.cpan.org/perldoc?XML::LibXML::SAX::Generator" target="_top"><code class="classname">XML::LibXML::SAX::Generator</code></a>, otra clase similar, declarada obsoleta.</p></li><li><p><b>Manejadores SAX. </b></p><p><a href="http://search.cpan.org/perldoc?XML::LibXML::SAX::Builder" target="_top"><code class="classname">XML::LibXML::SAX::Builder</code></a>, construye un árbol DOM desde eventos SAX.</p></li><li><p><b>Clases DOM. </b></p><p><a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Attr.pod" target="_top"><code class="classname">XML::LibXML::Attr</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/CDATASection.pod" target="_top"><code class="classname">XML::LibXML::CDATASection</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Comment.pod" target="_top"><code class="classname">XML::LibXML::Comment</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Document.pod" target="_top"><code class="classname">XML::LibXML::Document</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/DocumentFragment.pod" target="_top"><code class="classname">XML::LibXML::DocumentFragment</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Element.pod" target="_top"><code class="classname">XML::LibXML::Element</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/NamedNodeMap.pod" target="_top"><code class="classname">XML::LibXML::NamedNodeMap</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Node.pod" target="_top"><code class="classname">XML::LibXML::Node</code></a>,<a href="http://search.cpan.org/perldoc?XML::LibXML::Nodelist" target="_top"><code class="classname">XML::LibXML::Nodelist</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/PI.pod" target="_top"><code class="classname">XML::LibXML::PI</code></a>, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Text.pod" target="_top"><code class="classname">XML::LibXML::Text</code></a>.</p></li><li><p><b>Extensiones a DOM. </b></p><p><a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Namespace.pod" target="_top"><code class="classname">XML::LibXML::Namespace</code></a> es una clase añadida a las definidas por el estándard. El procesador <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Dtd.pod" target="_top"><code class="classname">XML::LibXML::Dtd</code></a> también provee de una clase específica no contemplada en DOM que sustituye parcialmente al interfaz DOM <code class="classname">DocumentType</code>.</p></li><li><p><b>Tipos de datos XPath. </b></p><p><a href="http://search.cpan.org/perldoc?XML::LibXML::Boolean" target="_top"><code class="classname">XML::LibXML::Boolean</code></a>; <a href="http://search.cpan.org/perldoc?XML::LibXML::Literal" target="_top"><code class="classname">XML::LibXML::Literal</code></a>; <a href="http://search.cpan.org/perldoc?XML::LibXML::Number" target="_top"><code class="classname">XML::LibXML::Number</code></a>.</p></li><li><p><b>Otros. </b></p><p><code class="classname">XML::LibXML::SAX::AttributeNode</code><sup>[<a name="id2408961" href="#ftn.id2408961">4</a>]</sup> (Obsoleta).</p></li></ul></div><p>Hay en CPAN otros módulos que añaden clases nuevas o subclasean las existentes:</p><div class="itemizedlist"><ul type="disc"><li><p><a href="http://search.cpan.org/perldoc?XML::LibXML::Fixup" target="_top">XML::LibXML::Fixup</a>, extiende el sistema de recuperación de errores de <code class="classname">LibXML::XML</code> permitiendo ligar acciones a estos errors, típicamente para permitir la continuación del procesado.</p></li><li><p><a href="http://search.cpan.org/perldoc?XML::LibXML::Iterator" target="_top">XML::LibXML::Iterator</a>, extensión a DOM, estructura los elementos linealmente, al estilo de la serialización de SAX, permitiendo su recorrido secuencial. En versiones anteriores de la distribución, <code class="methodname">iterator</code> era un método de XML::LibXML::Node.</p></li><li><p><a href="http://search.cpan.org/perldoc?XML::LibXML::NodeList::Iterator" target="_top">XML::LibXML::NodeList::Iterator</a>, subclase de XML::LibXML::NodeList que extiende DOM para permitir manejar los objetos NodeList como una lista, pudiendo moverse hacia arriba y abajo.</p></li><li><p><a href="http://search.cpan.org/perldoc?XML::LibXML::XPathContext" target="_top">XML::LibXML::XPathContext</a>, extensión a la capa XPath de <code class="classname">LibXML::XML</code> para utilizar contextos XPath.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2409049"></a>Procesamiento</h2></div></div></div><p>El uso habitual de la distribución es el procesado DOM. El procesador del módulo principal, <code class="classname">XML::LibXML</code>, genera objetos <code class="classname">XML::LibXML::Document</code> y <code class="classname">XML::LibXML::DocumentFragment</code>, a partir de textos XML, HTML y DocBook SGML (esto último desaconsejado). Los procesadores para las definiciones de documentos devuelven objetos de clases especiales, <code class="classname">XML::LibXML::Dtd</code>, <code class="classname">XML::LibXML::RelaxNG</code> y <code class="classname">XML::LibXML::Schema</code>.</p><p>El procesador <code class="classname">XML::LibXML::SAX</code> y los generadores <code class="classname">XML::LibXML::SAX::Parser</code> y <code class="classname">XML::LibXML::SAX::Generator</code> (obsoleto), devuelven eventos SAX, que pueden ser utilizados con cualquier sistema SAX2. La diferencia entre ellos es que <code class="classname">XML::LibXML::SAX</code> es un procesador SAX nativo, mientras los generadores son una capa añadida al procesador DOM, que atraviesa el árbol ya creado y provee de eventos desde él.</p><p>Estos procesadores son muy flexibles a la hora de recibir datos. Le pueden llegar desde archivos o cadenas (escalares) que contengan los documentos. En el caso de cadenas, éstas pueden ser sólo fragmentos balanceados, no necesariamente bien formados. También pueden ser su fuente Perl filehandles, y flujos de caracteres, quizá discontinuos y no necesariamente agrupados en cadenas con texto XML bien formado.</p><p>Para cada uno de las diversas entradas de datos nos provee de un método distinto de invocarlo. Los métodos DOM a su vez se desdoblan según el texto de entrada sea XML, HTML o DocBook SGML.</p><p>No todas las modalidades están disponibles para todos los procesadores. Esta tabla resume las posibilidades:</p><div class="table"><a name="id2409148"></a><p class="title"><b>Table 1. Tipos de procesamiento</b></p><table summary="Tipos de procesamiento" border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th rowspan="2" align="center" valign="middle"><p>Procesador</p></th><th rowspan="2" align="center" valign="middle"><p>Textos</p></th><th colspan="4" align="center"><p>Bien Formados</p></th><th align="center"><p>Balanceados</p></th></tr><tr><th align="center"><p> Archivos</p></th><th align="center"><p>Cadenas</p></th><th align="center"><p>Filehandles</p></th><th align="center"><p>Flujos</p></th><th align="center"><p>Cadenas</p></th></tr></thead><tbody><tr><td rowspan="3" align="center" valign="middle"><p>XML::LibXML</p></td><td align="center"><p>XML</p></td><td align="center"><p>parse_file</p></td><td align="center"><p>parse_string</p></td><td align="center"><p>parse_fh</p></td><td align="center"><p>parse_chunk,start_push, push,finish_push</p></td><td align="center"><p>parse_balanced_chunk</p></td></tr><tr><td align="center"><p>HTML</p></td><td align="center"><p>parse_html_file</p></td><td align="center"><p>parse_html_string</p></td><td align="center"><p>parse_html_fh</p></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center"><p>DocBook SGML</p></td><td align="center"><p>parse_sgml_file</p></td><td align="center"><p>parse_sgm_string</p></td><td align="center"><p>parse_sgml_fh</p></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center"><p>XML::LibXML::Dtd</p></td><td align="center"><p>DTD</p></td><td align="center"><p>new</p></td><td align="center"><p>parse_string</p></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center"><p>XML::LibXML::RelaxNG</p></td><td align="center"><p>RelaxNG</p></td><td align="center"><p>new</p></td><td align="center"><p>new</p></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center"><p>XML::LibXML::Schema</p></td><td align="center"><p>esquemas XML</p></td><td align="center"><p>new</p></td><td align="center"><p>new</p></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center"><p>XML::LibXML::SAX</p></td><td align="center"><p>XML</p></td><td align="center"><p>parse_uri,parse_file</p></td><td align="center"><p>parse_string</p></td><td align="center"><p></p></td><td align="center"><p>parse_chunk</p></td><td class="auto-generated"> </td></tr><tr><td align="center"><p>XML::LibXML::SAX::Parser</p></td><td align="center"><p>XML</p></td><td align="center"><p>parse_uri,parse_file</p></td><td align="center"><p>parse_string</p></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr></tr></tbody></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2460823"></a>Textos HTML y DocBook SGML</h3></div></div></div><p><code class="classname">XML::LibXML</code> permite procesar algunos archivos SGML, y en concreto HTML  y DocBook SGML. El soporte no es completo, sin embargo, y he tenido diferentes éxitos en su uso.</p><p>El soporte de <a href="http://www.w3.org/TR/html401/" target="_top">HTML 4.01</a> (sin validación) es bastante bueno. La documentación del módulo recomienda evitar el carácter &amp;, típicamente usado en enlaces a webs basadas en cgi, y que se cierren los elementos con la etiqueta final en los casos en que sea optativo en HTML.</p><p>El uso parece satisfactorio para los tipos de documento <a href="http://www.w3.org/TR/REC-html40/loose.dtd" target="_top">transitional</a>  y <a href="http://www.w3.org/TR/REC-html40/strict.dtd" target="_top">strict</a> y he podido procesar con sólo un error los <a href="http://www.w3.org/MarkUp/Test/HTML401/current/tests/" target="_top">test del W3C</a><sup>[<a name="id2460883" href="#ftn.id2460883">5</a>]</sup>.</p><p>El tipo de documento <a href="http://www.w3.org/TR/REC-html40/frameset.dtd" target="_top">frameset</a> en cambio no se procesa correctamente.</p><p>Aunque libxml2 todavía incluye el uso de funciones para el procesado de DocBook SGML, esta capa está declarada <a href="http://xmlsoft.org/html/libxml-DOCBparser.html" target="_top">obsoleta</a>. En consonancia, los documentos que he utilizado como prueba de procesamiento han dado errores; en general recomendaremos que NO se utilicen las funciones correspondientes a este tipo de documento.</p><p>Pese al nombre de las funciones y a que la documentación de <code class="classname">XML::LibXML</code> no es suficiente explícita en todos los casos, ha de remarcarse que el soporte de SGML es muy parcial, y los métodos <code class="methodname">parse_sgml_file</code> y <code class="methodname">parse_sgml_string</code>, no son para el procesado genérico de documentos SGML, sino para DocBook SGML, ya que usan respectivamente las funciones de libxml2 <a href="http://xmlsoft.org/html/libxml-DOCBparser.html#docbParseFile" target="_top"><code class="function">docbParseFile</code></a><sup>[<a name="id2460963" href="#ftn.id2460963">6</a>]</sup> y <a href="http://xmlsoft.org/html/libxml-DOCBparser.html#docbParseDoc" target="_top"> <code class="function">docbParseDoc</code></a><sup>[<a name="id2460976" href="#ftn.id2460976">7</a>]</sup>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2460983"></a>Procesamiento de archivos</h3></div></div></div><p>El camino más habitual de obtener la fuente XML para el procesamiento será un archivo. Para ellos podemos utilizar el el método <code class="methodname">parse_file</code> de <code class="classname">XML::LibXML</code>:</p><pre class="programlisting">#!/usr/bin/perl -w
use XML::LibXML;
my $parser = XML::LibXML-&gt;new();
my $doc =$parser-&gt;parse_file('hola.xml');</pre><p>Pese a que su nombre pueda reflejar ambigüedad, las funciones del procesador DOM que se refieren a archivos admiten indistintamente referencias al sistema de ficheros local y URIs, cuyos enlaces pueden ser externos.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2461020"></a>Tratamiento de URIs</h4></div></div></div><p>libxml2 implementa internamente clientes ftp y http, por lo que podemos utilizar de manera transparente URIs de estos protocolos, tanto al indicarle al procesador que se desea tratar un archivo, como a la hora de colocar en el texto referencias a entidades externas o enlaces Xinclude.</p><p>En ambos casos el procesador <code class="classname">XML::LibXML</code> los trata como si de archivos locales se tratara. En consonancia con su uso transparente, el módulo ha previsto sólamente un diálogo simple con el servidor, por ejemplo el uso de ftp anónimo, sin implementar una capa compleja que lidie con el protocolo, por ejemplo ante el uso de proxies o de autentificación.</p><p>Si este uso simple no fuera suficiente, si deseáramos cambiar las URIs existentes en los documentos por otras, o habilitar el acceso a URIs de protocolos diferentes, tenemos la posibilidad de hacerlo, aunque en este caso nos queda a nosotros el implementar el diálogo con el servidor.</p><p>En este caso disponemos de métodos adicionales para dar instrucciones concretas al procesador para unas URIs determinadas.</p><p>El método <a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#match_callback" target="_top"><code class="methodname">match_callback</code></a> nos permite indicar qué patrón debe buscarse en la URI. Nos remite a una función (una referencia a ella en realidad), que hará la tarea:</p><pre class="programlisting">$parser-&gt;match_callback($subref);</pre><p>Si la rutina indicada devuelve 1, es decir se cumple ese patrón, el procesador ejecutará las funciones que hemos indicado para él. La búsqueda tiene prioridad ante otros patrones internos de libxml2, por lo que si se activa no buscará en otros tipos de URIs; en caso de que no se siga el patrón, el procesador seguirá su curso normal.</p><p>Podemos crear funciones específicas para tres acciones que toma el procesador al tratar la URI:  <a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#open_callback" target="_top"> <code class="methodname">open_callback</code> </a>, al abrirla, <a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#read_callback" target="_top"><code class="methodname">read_callback</code></a>, al leer datos del archivo referido por la URI, y <a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#close_callback" target="_top"><code class="methodname">close_callback</code></a>, al cerrarlo.</p><p>En este ejemplo implementaremos unas funcionas básicas para gestionar URIs del protocolo tftp:</p><pre class="programlisting">#!/usr/bin/perl -w
use XML::LibXML;
use Net::TFTP;

my $parser = XML::LibXML-&gt;new();
$parser-&gt;match_callback( \&amp;match_uri );
$parser-&gt;read_callback( \&amp;read_uri );
$parser-&gt;open_callback( \&amp;open_uri );
$parser-&gt;close_callback( \&amp;close_uri );

$doc=$parser-&gt;parse_file('tftp://localhost/sidebar.xml');
print $doc-&gt;toString();

sub match_uri {
    my $uri = shift;
    return $uri =~ /^tftp:\/\// ? 1 : 0; 
}
sub open_uri {
	my $uri = shift;
	$uri =~ /^tftp:\/\/([^\/]*)\/(.*)/;
	my $server=$1;
	my $file=$2;
	my $tftp = Net::TFTP-&gt;new($server, BlockSize =&gt; 1024);
	$tftp-&gt;binary;
	$tftp-&gt;get($file, "$file"); # /tmp/$file
	my $handler = new IO::File "$file"; # /tmp/$file
	return $handler;
}
sub read_uri {
    my $handler = shift;
    my $length  = shift;
    my $buffer = undef;
    if ( $handler ) {
        $handler-&gt;read( $buffer, $length );
    }
    return $buffer;
}
sub close_uri {
    my $handler = shift;
    if ( $handler ) {
        $handler-&gt;close();
    }
    return 1;
}</pre><p>En nuestro ejemplo, la URI del archivo a procesar por el método <code class="methodname">parse_file</code> es <code class="literal">tftp://localhost/sidebar.xml</code>.</p><p>La función match_uri sevuelve 1 si la URI comienza por la cadena "tftp://", e inicia el procesado alternativo.</p><p>El grueso del trabajo lo realizará la función <code class="function">open_uri</code>. Ésta debe devolver un manejador de archivo, y tenemos varios métodos de implementar esto. Aquí utilizamos el más sencillo, guardar el archivo remoto en un directorio temporal, tras traerlo con <a href="http://search.cpan.org/perldoc?Net::TFTP" target="_top">Net::TFTP</a>, y abrirlo entonces mediante <a href="http://search.cpan.org/perldoc?IO::File" target="_top">IO::File</a>, que nos proporciona el manejador necesario.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2461216"></a>Compresión</h4></div></div></div><p><code class="classname">XML::LibXML</code> permite utilizar archivos locales comprimidos con <a href="http://www.gnu.org/software/gzip/gzip.html" target="_top">gzip</a>. Esta funcionalidad no está disponible con la gestión de URIs http o ftp, aunque lógicamente se podría implementar una similar mediante médodos de gestión propios para determinadas URIs, como hemos visto.</p><p>Simplemente se ha de utilizar un método de procesamiento de archivos, por ejemplo <code class="methodname">parse_file</code>:</p><pre class="programlisting">my $doc = $parser-&gt;parse_file('sidebar.xml.gz');</pre><p>En el proceso contrario, si se vuelca un objeto <code class="classname">XML::LibXML::Document</code> a un archivo, com el método <code class="methodname">toFile</code> es posible obtener una salida comprimida con zlib ( <span><strong class="command">gzip</strong></span>). Ello dependerá obviamente de que libxml2 esté compilada con la opción de utilizar <a href="http://www.zlib.net/" target="_top">zlib</a>.</p><p>Esta funcionalidad se controla mediante una variable interna, que podemos consultar con el método <code class="methodname">compression</code>, o modificar mediante el método <code class="methodname">setCompression</code> de un objeto <code class="classname">XML::LibXML::Document</code>. </p><p>En ausencia de compresión, la variable toma el valor -1, y si es positivo, es decir, está habilitada la compresión, guarda la ratio de compresión, que para <span><strong class="command">gzip</strong></span> puede ser de 1 a 9.</p><p>Así, para volcar el árbol DOM del documento completo a un archivo, con la máxima compresión:</p><pre class="programlisting">$doc-&gt;setCompression(9);
print my $state=$doc-&gt;toFile("/tmp/sidebar.xml.gz");</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2461327"></a>Cadenas</h3></div></div></div><p>Hemos visto que varios de los procesadores de <code class="classname">XML::LibXML</code> nos permiten utilizar las típicas cadenas de texto XML construidas previamente dentro de nuestra aplicación Perl, guardadas en un escalar, por ejemplo <code class="methodname">XML::LibXML-&gt;parse_string</code>.</p><pre class="programlisting">use XML::LibXML;
my $parser = XML::LibXML-&gt;new();
my $doc = $parser-&gt;parse_string(&lt;&lt;'FIN');
&lt;html&gt;&lt;body&gt;&lt;p&gt;hola mundo&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
FIN
print $doc-&gt;toString();</pre><p>El texto procesado por <code class="methodname">parse_string</code> ha de ser un texto
<a href="http://www.w3.org/TR/REC-xml#sec-well-formed" target="_top">bien formado</a>, lo que conlleva una serie de restricciones al texto, sus atributos o el tratamiento de las entidades.</p><p>Esto es adecuado para textos XML completos, pero cuando procesamos fragmentos de texto XML es posible que no se cumplan todos los requisitos. Para estos casos contamos con otro método de procesamiento alternativo menos
estricto, <code class="methodname">parse_balanced_chunk</code>, que permite procesar cadenas de texto XML con la única condición de que sea <a href="http://www.w3.org/TR/xml-fragment" target="_top">balanceado</a>,
es decir que debe existir una etiqueta final por cada etiqueta inicial.</p><p>En este ejemplo el fragmento no es un elemento completo, es decir no contiene un elemento raíz, sino dos elementos, el primero un texto (un elemento <span class="type">CharData</span>), pero el procesador puede seguir su tarea:</p><pre class="programlisting">#!/usr/bin/perl -w
use XML::LibXML;
my $parser = XML::LibXML-&gt;new();
my $doc = $parser-&gt;parse_balanced_chunk(&lt;&lt;'FIN');
hola &lt;i&gt;mundo&lt;/i&gt;
FIN
print $doc-&gt;toString();</pre><p>Aunque el texto entrante sólo debe ser balanceado, los nodos Element que contenga sí deben ser bien formados. Esto es especialmente importante si se usan entidades: el fragmento debe contener también las indicaciones para resolverlas, o el procesador dará errores.</p><p>El procesador DOM <code class="methodname">XML::LibXML</code> devuelve objetos <code class="methodname">XML::LibXML::DocumentFragment</code> al invocar el método <code class="methodname">parse_balanced_chunk</code>.</p><p>Cuando tratamos con cadenas de texto XML hay algunas limitaciones al uso del procesador. Una de ellas es que si usamos URIs relativas en los documentos el procesador no puede convertirlas en reales, porque no sabe la URI
del texto inicial, con lo que otras muchas opciones como usar Xinclude, DTDs o entidades externas quedan comprometidas. En esos caso podemos añadir un segundo parámetro al método de procesamiento <code class="methodname">parse_string</code>, con
la URI base del flujo:</p><pre class="programlisting">my $doc = $parser-&gt;parse_string( $xmlstring, $baseuri);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2461469"></a>Flujos y fragmentos</h3></div></div></div><p>Cuando el proceso va a trabajar en ráfagas, en vez de recibir todos los datos de una sola vez, podemos utilizar el modo de procesamiento que la documentación denomina <code class="literal">push</code>. En este caso el procesador es capaz de manejar trozos del texto XML, e irlos procesando a medida que llegan, guardando el estado de lo que lleva recolectado.</p><p>Este sistema es bastante diferente del también llamado <code class="literal">procesado push</code> que llevan a cabo los módulos <a href="http://search.cpan.org/perldoc?XML::Filter::Dispatcher" target="_top">XML::Filter::Dispatcher</a> y <a href="http://search.cpan.org/perldoc?XML::Filter::Dispatcher" target="_top">XML::Twig</a>.</p><p>Se parece a ellos en que efectivamente el procesador está pasivo a la espera de ls actuaciones de la aplicación en la fase de recepción de datos. Pero en estos últimos la aplicación solicita al procesador determinada información, lo contrario a SAX, donde el procesador va generando información (eventos) y la aplicación es quien la selecciona. En <code class="classname">XML::LibXML::SAX</code> el procesador va acumulando toda la información mientras está a la espera, y al final dispondrá de la representación completa del texto XML, a la que podremos tratar posteriormente.</p><p>El modo <code class="literal">push</code> del procesador puede ser utilizado en <code class="classname">XML::LibXML</code> con filehandles y con cadenas de texto, y en <code class="classname">XML::LibXML::SAX</code> con cadenas. En el primer caso, aún se dispone de una capa de bajo nivel si se desea un mayor control.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2461557"></a>FileHandle</h4></div></div></div><p>El primer método que podemos usar para una recepción a ráfagas está basado en el tratamiento de un flujo de datos. La llamada al procesador <code class="methodname">parse_fh</code> nos permite utilizar para el flujo cualquier manejador de entrada (handler) que pueda gestionarse desde Perl. En este caso se le indica al procesador una referencia al manejador o un objeto <a href="http://search.cpan.org/perldoc?IO::Handle" target="_top">IO::Handle</a>.</p><p>Así podemos modificar el código incial para que obtenga el texto XML de la entrada estándard:</p><pre class="programlisting">#!/usr/bin/perl -w
use XML::LibXML;
my $parser = XML::LibXML-&gt;new();
$ioref     = *STDIN{IO};
$doc = $parser-&gt;parse_fh( $ioref );
print $doc-&gt;toString();</pre><p>Y ya podemos usarla en una tubería:</p><pre class="programlisting">cat prueba.xml | prueba.pl;</pre><p>En este método el procesado continúa hasta que se detecta el fin de la entrada, por ejemplo en un archivo hasta que llega al final del mismo.</p><p>El método <code class="methodname">parse_fh</code> admite también un segundo parámetro, para indicar la URI base, que se usa igual que lo hacíamos con <code class="methodname">parse_string</code>:</p><pre class="programlisting">$doc = $parser-&gt;parse_fh( $ioref, $baseuri);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2461632"></a>Fragmentos como cadenas</h4></div></div></div><p>Otro método, <code class="methodname">parse_chunk</code>, nos permite utilizar las ráfagas en cadenas de texto. </p><pre class="programlisting">use XML::LibXML;
  my $parser = XML::LibXML-&gt;new;
  for my $string ( "&lt;", "hola a todos", "/&gt;") {
       $parser-&gt;parse_chunk( $string );
  }
  my $doc = $parser-&gt;parse_chunk("", 1); # terminate the parsing
print $doc-&gt;toString;</pre><p>En este caso el procesador no sabe cuándo ha llegado la última cadena, y hemos de indicársela expresamente, con un segundo parámetro que activa el flag de fin de la entrada.</p><p>Aquí no dispondremos de la posibilidad de indicar una URI base para textos que incluyan rutas relativas.</p><p>Si los métodos anteriores no son suficientes para nuestro entorno, por ejemplo, porque la fuente de datos produce errores, aún podemos utilizar el procesador push a bajo nivel. En este caso, obviamente, armar el proceso es más parecido al trabajo real de los datos con libxml2, no como en el caso anterior en que <code class="classname">LibXML::XML</code> hacía todo el trabajo por nosotros. Debemos inicializar la matriz de cadenas con el método <code class="methodname">start_push</code>, llenarla con <code class="methodname">push</code> y declararla con el método <code class="methodname">finish_push</code>.</p><p>A cambio, aquí es posible utilizar las facilidades de recuperación de errores del procesador, como hacemos con del método <code class="methodname">recover</code> del modo pull; en caso de error en el procesado de una de las secuencias aún es posible continuar. Para activarlas enviamos un 1 como parámetro al método <code class="methodname">finish_push</code>.</p><pre class="programlisting">use XML::LibXML;
my $parser = XML::LibXML-&gt;new;
eval {
	for my $string ( "&lt;hola&gt;", "a" , "&lt;todos/&gt;") {
       		$parser-&gt;push( $string);
  	}
	$doc = $parser-&gt;finish_push(1);
};
print $doc-&gt;toString();</pre><p>En esta variante de los ejemplos anteriores el elemento <code class="sgmltag-element">hola</code> está roto, y el procesador lo advierte, pero aún así continúa procesando el texto e intenta reparar el error:</p><pre class="screen">Entity: line 1: parser error : Extra content at the end of the document
&lt;hola&gt;a&lt;todos/&gt;
               ^
&lt;?xml version="1.0"?&gt;
&lt;hola&gt;a&lt;todos/&gt;&lt;/hola&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2461748"></a>El procesador DOM</h3></div></div></div><p>El esquema general de trabajo con el procesador DOM, <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Parser.pod" target="_top"><code class="classname">XML::LibXML</code></a>, podría ser éste:</p><div class="mediaobject"><img src="tratamiento.png" alt="Esquema general del procesamiento con XML::LibXML"><div class="caption"><p>Esquema general del procesamiento con XML::LibXML</p></div></div><p>La inicialización crea la instancia del módulo e instruye al procesador de las opciones que deseemos para modificar su conducta.</p><p>Tras ello pasaremos a invocar a el procesador, eligiendo alguna de las múltiples alternativas existentes, entre procesado DOM, pull o push, y SAX. Es posible que el documento sea reprocesado una segunda vez, si se necesitara completar con datos externos, por el uso de XInclude. Al final de esta etapa contamos con una estructura de datos que representa la información XML contenida en el texto de entrada.</p><p>En la última fase haremos algo con esos datos.</p><p>En realidad esto puede complicarse sensiblemente, por ejemplo puede colocarse una capa de validación después del procesamiento, o este tratamiento se puede ensartar en otros procesos que también tratan XML, quizá al utilizarse como procesador un manejador SAX que recontruye el árbol DOM desde eventos SAX (<code class="classname">XML::LibXML::SAX::Builder</code>), y así múltiples variantes. Pero el esquema general nos sirve de guía.</p><p>Obsérvese que el procesador puede ser utilizado para el tratamiento de varios textos XML, pero es único. Esto tiene consecuencias importantes en trabajos en cadena: Si se rompe el proceso por error en el tratamiento de un archivo,  <code class="classname">LibXML::XML</code>  pierde la conexión con libxml2 y la cadena se interrumpe, el resto no será tenido en cuenta, aunque contuviera datos sin errores. Veremos luego que <code class="classname">LibXML::XML</code> provee de algún mecanismo para tratar textos conflictivos.</p><p>La segunda consecuencia del esquema es que las opciones son globales, afectan a todos los textos. Es posible ir cambiando el comportamiento del procesador para cada texto en concreto, pero estos cambios han de ser explícitamente declarados y revocados más tarde, pues sus efectos son permanentes.</p><p>La fase de inicialización parte del método <code class="methodname">new</code> que crea la instancia del objeto procesador, y antes de llamarlo podemos modificar algunas opciones.</p><pre class="programlisting">my $parser = XML::LibXML-&gt;new();;</pre><p>El objeto procesador que hemos obtenido al inicializar el módulo nos prevee de varios métodos para cambiar las condiciones de trabajo. En su mayor parte son flags, y reciben como parámetro un 1 para habilitar la opción o un 0 para deshabilitarla.</p><div class="itemizedlist"><ul type="disc"><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#validation%20validation" target="_top">validation</a>. </b></p><p>Si se activa esta opción obliga al procesador a validar el documento contra un DTD. Por defecto está deshabilitado.</p><pre class="programlisting">$parser-&gt;validation(1);</pre><p>Si el documento no es válido, el procesador provocará un error que interrumpirá el proceso.</p><p>La validación contra un DTD puede realizarse no obstante después del procesamiento, llamando al método <code class="methodname">&gt;is_valid</code>.</p></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#recover" target="_top">recover</a>. </b></p><p>Por defecto el procesador falla si el documento no está bien formado. Por ejemplo aquí nos hemos olvidado de cerrar el elemento <code class="varname">title</code>:</p><pre class="programlisting">&lt;sidebar&gt;&lt;section&gt;
   &lt;title&gt;Mi web
        &lt;item&gt;
                &lt;title&gt;Informacion&lt;/title&gt;
                &lt;url&gt;/Informacion/&lt;/url&gt;
        &lt;/item&gt;
   &lt;/section&gt;&lt;/sidebar&gt;</pre><p>Lo que hace que el proceso no termine:</p><pre class="screen">sidebar.xml:9: parser error : Opening and ending tag mismatch: title line 4 and section
   &lt;/section&gt;&lt;/sidebar&gt;
             ^
sidebar.xml:9: parser error : Opening and ending tag mismatch: section line 3 and sidebar
   &lt;/section&gt;&lt;/sidebar&gt;
                       ^
sidebar.xml:10: parser error : Premature end of data in tag sidebar line 3
^
 at sidebar.pl line 7</pre><p>Si embargo si habilitamos la opción recover</p><pre class="programlisting">$parser-&gt;recover(1);
my $source = $parser-&gt;parse_file('sidebar.xml');
print $source-&gt;toString;</pre><p>el procesador seguirá ofreciendo los errores anteriores, pero intentará en la medida de lo posible restaurar las etiquetas perdidas hasta completar los elementos, dando una salida bien formada, esperando que sea también válida:</p><pre class="screen">&lt;sidebar&gt;&lt;section&gt;
   &lt;title&gt;Mi web
        &lt;item&gt;
                &lt;title&gt;Informacion&lt;/title&gt;
                &lt;url&gt;/Informacion/&lt;/url&gt;
        &lt;/item&gt;
&lt;/title&gt;&lt;/section&gt;&lt;/sidebar&gt;</pre><p>En este caso vemos que ha tenido un éxito limitado al restaurar el original, pero el proceso ha podido seguir y los daños se han minimizado.</p><p>Esta opción es útil cuando procesamos documentos no seguros, por ejemplo los generados en tiempo real por formularios web, o documentos HTML o SGML en previsión de que el procesador no sea capaz de balancear elementos u otros errores.</p><p>Para un mayor control de los errores podemos acudir a la extensión <a href="http://search.cpan.org/perldoc?XML::LibXML::Fixup" target="_top">XML::LibXML::Fixup</a>, que los intercepta y permite efectuar acciones, quizá reparadoras, y continuar el procesamiento.</p></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#expand_entities" target="_top">expand_entities</a>. </b></p><p>Por defecto las entidades externas se expanden, pero puede cambiarse el comportamiento, deshabilitando la opción. Es casi seguro que si el documento tiene entidades externas querremos que se tengan en cuenta, por lo que quizá esto tan sólo es útil en algunos contextos de depuración.</p><pre class="programlisting">$parser-&gt;expand_entities(0);</pre></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#keep_blanks" target="_top">keep_blanks</a>. </b></p><p>Si se mantienen los elementos constituidos en exclusiva por espacios en blanco. Estos elementos se incluyen sobre todo para una lectura más fácil del texto XML, por ejemplo indentándolo.</p><pre class="programlisting">$parser-&gt;keep_blanks(0);</pre><p>Por defecto la opción es afirmativa. Si se anula el texto XML se compacta, y un volcado de los datos procesados ofrecerá un documento de una sola línea.</p></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#pedantic_parser" target="_top">pedantic_parser</a>. </b></p><p>Esta opción añade mensajes adicionales de atención analizando varias cuestiones, típicamente para algunos casos de depuración:</p><div class="itemizedlist"><ul type="circle"><li><p>los valores <a href="http://www.w3.org/TR/WD-xml-lang-970331" target="_top">xml:lang</a></p></li><li><p>redeclaración de entidades</p></li><li><p>nombres de los espacios de nombres en conformidad con el <a href="http://www.ietf.org/rfc/rfc2396.txt" target="_top">RFC 2396</a> o si no son URIs absolutas</p></li></ul></div><p>Por defecto la opción está deshabilitada.</p><pre class="programlisting">$parser-&gt;pedantic_parser(1);</pre></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#line_numbers" target="_top">line_numbers</a>. </b></p><p>Esta opción hace que el procesador guarde el número de línea de un nodo, habitualmente para depuración. Por defecto está deshabilitado.</p><pre class="programlisting">$parser-&gt;line_numbers(1);</pre></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#load_ext_dtd" target="_top">load_ext_dtd</a>. </b></p><p>Si expande el DTD externo cuando no hay validación. No tiene efecto en la validación. Si no se especifica valor, está deshabilitado.</p><pre class="programlisting">$parser-&gt;load_ext_dtd(1);</pre></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#complete_attributes" target="_top">complete_attributes</a>. </b></p><p>Esta opción completa el documento original con los atributos por defecto que estuvieran incluidos en la declaración de tipo de documento. Para ello se carga el DTD aunque no se especifique explícitamente con otras opciones.</p><pre class="programlisting">$parser-&gt;complete_attributes(1);</pre><p>Así, si en el DTD un elemento <code class="varname">subsection</code> contiene un atributo <code class="varname">expand</code> de valor <code class="literal">no</code>,</p><pre class="programlisting">&lt;!ATTLIST subsection expand ( yes | no ) "no"&gt;</pre><p>la habilitación de esta opción en un texto que incluya el elmento sin atributos,</p><pre class="programlisting">&lt;subsection&gt; ...&lt;/subsection&gt;</pre><p>provocará que el original quede modificado, y un volcado del elemento mostrará el atributo con su valor por defecto:</p><pre class="screen">&lt;subsection expand="no"&gt;...&lt;/subsection&gt;</pre></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#expand_xinclude" target="_top">expand_xinclude</a>. </b></p><p>Expande los elementos XInclude al tiempo del procesamiento.</p><pre class="programlisting">$parser-&gt;expand_xinclude(1);</pre><p>Es posible procesar los elementos de Xinclude en una segunda pasada del procesador, mediante el método <code class="methodname">process_xincludes</code>.</p></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#load_catalog" target="_top">load_catalog</a>. </b></p><p>Esta opción permite indicar un catálogo a utilizar en el procesamiento:</p><pre class="programlisting">$parser-&gt;load_catalog( $catalog_file );</pre><p>Los <a href="http://www.oasis-open.org/committees/entity/spec-2001-08-06.html" target="_top">catálogos</a> son tablas que mapean uris externas de acceso a recursos XML (DTD, esquemas, hojas de estilo,... ) con archivos situados en el sistema de ficheros local. Típicamente permiten usar copias locales de las definiciones de documento y hojas de estilo estándares, para facilitar la rapidez del proceso.</p><p>La implementación de LibXML no permite utilizar esta opción juntamente con la carga de entidades externas.</p></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#base_uri" target="_top">base_uri</a>. </b></p><p>Permite indicar una uri base que puedan utilizar los documentos XML o XSL que contengan enlaces relativos, por ejemplo de DTDs, entidades externas o documentos enlazados con XInclude.:</p><pre class="programlisting">$parser-&gt;base_uri( $base_uri );</pre></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#gdome_dom" target="_top">gdome_dom</a>. </b></p><p><code class="classname">XML::LibXML</code> puede ser utilizado para procesar datos que después sean utilizados con <a href="http://search.cpan.org/perldoc?XML::GDOME" target="_top"><code class="classname">XML::GDOME</code></a>, un interfaz Perl a la librería <a href="http://gdome2.cs.unibo.it/" target="_top">gdome</a>, a su vez una versión de libxml2 más respetuosa con los estándares DOM. Esta opción, calificada como experimental, permite configurar a <code class="classname">LibXML::XML</code> para que el resultado del procesamiento fuerce esta interoperatividad.</p><pre class="programlisting">$parser-&gt;gdome_dom(1);</pre></li><li><p><b><a href="http://search.cpan.org/perldoc?XML::LibXML::Parser#clean_namespaces" target="_top">clean_namespaces</a>. </b></p><p>Esta opción permite eliminar declaraciones redundanes de espacios de nombres en el árbol DOM. Por defecto está deshabilitada.</p><pre class="programlisting">$parser-&gt;clean_namespaces(1);</pre></li></ul></div><p>La mayoría de las opciones de <code class="classname">LibXML::XML</code> afectan a valores de la estructura de libxml2 <span class="structname"><a href="http://xmlsoft.org/html/libxml-globals.html" target="_top">xmlGlobalState</a></span>. Éste es el mapa, tal como lo podemos extraer de las funciones que modifican el hash <code class="varname">%options</code><sup>[<a name="id2462470" href="#ftn.id2462470">8</a>]</sup>,  y la que modifica <span class="structname">xmlGlobalState</span>,<code class="function">LibXML_init_parser</code><sup>[<a name="id2462482" href="#ftn.id2462482">9</a>]</sup>.</p><div class="table"><a name="id2462488"></a><p class="title"><b>Table 2. Correspondecia de opciones <code class="classname">LibXML::XML</code> y libxml2</b></p><table summary="Correspondecia de opciones LibXML::XML y libxml2" border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center"><p>método</p></th><th align="center"><p>clave de %options</p></th><th align="center"><p>xmlGlobalState</p></th><th align="center"><p>Defecto
</p></th></tr></thead><tbody><tr><td rowspan="2" align="center" valign="middle"><p>validation</p></td><td rowspan="2" align="center" valign="middle"><p>XML_LIBXML_VALIDATION</p></td><td align="center"><p>xmlDoValidityCheckingDefaultValue</p></td><td rowspan="2" align="center" valign="middle"><p>No
</p></td></tr><tr><td align="center"><p>xmlLoadExtDtdDefaultValue</p></td></tr><tr><td rowspan="2" align="center" valign="middle"><p>expand_entities</p></td><td rowspan="2" align="center" valign="middle"><p>XML_LIBXML_EXPAND_ENTITIES</p></td><td align="center"><p>xmlSubstituteEntitiesDefaultValue</p></td><td rowspan="2" align="center" valign="middle"><p>No
</p></td></tr><tr><td align="center"><p>xmlLoadExtDtdDefaultValue</p></td></tr><tr><td align="center"><p>keep_blanks</p></td><td align="center"><p>XML_LIBXML_KEEP_BLANKS</p></td><td align="center"><p>xmlKeepBlanksDefaultValue</p></td><td align="center"><p>Sí
</p></td></tr><tr><td align="center"><p>pedantic_parser</p></td><td align="center"><p>XML_LIBXML_PEDANTIC</p></td><td align="center"><p>xmlPedanticParserDefaultValue</p></td><td align="center"><p>No
</p></td></tr><tr><td align="center"><p>line_numbers </p></td><td align="center"><p>XML_LIBXML_LINENUMBERS</p></td><td align="center"><p>xmlLineNumbersDefaultValue</p></td><td align="center"><p>No
</p></td></tr><tr><td align="center"><p>load_ext_dtd</p></td><td align="center"><p>XML_LIBXML_EXT_DTD</p></td><td align="center"><p>xmlLoadExtDtdDefaultValue</p></td><td align="center"><p>No
</p></td></tr><tr><td align="center"><p>complete_attributes</p></td><td align="center"><p>XML_LIBXML_COMPLETE_ATTR</p></td><td align="center"><p>xmlLoadExtDtdDefaultValue</p></td><td align="center"><p>No
</p></td></tr><tr><td align="center"><p>recover</p></td><td align="center"><p>XML_LIBXML_RECOVER</p></td><td align="center"><p></p></td><td align="center"><p>No
</p></td></tr><tr><td align="center"><p>expand_xinclude</p></td><td align="center"><p>XML_LIBXML_EXPAND_XINCLUDE</p></td><td align="center"><p></p></td><td align="center"><p>Sí
</p></td></tr><tr><td align="center"><p>base_uri </p></td><td align="center"><p>XML_LIBXML_BASE_URI
</p></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center"><p>gdome_dom </p></td><td align="center"><p>XML_LIBXML_GDOME</p></td><td align="center"><p></p></td><td align="center"><p>No
</p></td></tr><tr></tr><tr></tr></tbody></table></div><p>Observemos que algunas de las opciones automáticamente activan otras. Si activamos <code class="methodname">validation</code>, es decir decimos a <code class="classname">LibXML::XML</code> que deseamos que valide el documento, automáticamente se activa el indicador de que se carge el DTD, o sea <code class="methodname">load_ext_dtd</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2462851"></a>SAX</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2462855"></a>Procesador SAX</h4></div></div></div><p><a href="http://search.cpan.org/perldoc?XML::LibXML::SAX" target="_top">XML::LibXML::SAX</a> provee un procesador <a href="http://perl-xml.sourceforge.net/perl-sax/" target="_top">PerlSAX</a>. Su uso más simple, como es habitual en SAX, encadena un procesador a un manejador, al que pasa los eventos.</p><p>Así, en este ejemplo, utilizamos el manejador <a href="http://search.cpan.org/perldoc?XML::Handler::PrintEvents" target="_top">XML::Handler::PrintEvents</a>, que imprime un informe de cada evento que recibe:</p><pre class="programlisting">#!/usr/bin/perl -w
use XML::LibXML::SAX;
use XML::Handler::PrintEvents;
my $p = XML::LibXML::SAX-&gt;new(Handler =&gt; XML::Handler::PrintEvents-&gt;new);
$p-&gt;parse_uri("sidebar.xml");</pre><p>Este procesador es puro SAX, no construye el árbo DOM de los datos con que va trabajando; en su lugar va generando los eventos.</p><p>A los métodos de SAX2 se le añade uno nuevo, <code class="methodname">parse_chunk</code>, que permite utilizar las facilidades del libxml2 con textos incompletos, aqunque balanceados, como hace el método <code class="methodname">parse_balanced_chunk</code> del procesador DOM.</p><pre class="programlisting">$p-&gt;parse_chunk($cadena');</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2462927"></a>SAX desde DOM</h4></div></div></div><p><a href="http://search.cpan.org/perldoc?XML::LibXML::SAX::Parser" target="_top">XML::LibXML::SAX::Parser</a> provee de un generador <a href="http://perl-xml.sourceforge.net/perl-sax/" target="_top">PerlSAX</a> a partir de un árbol DOM. No es un procesador de flujo, simplemente produce una lista de eventos que se pueden utilizar en la tubería SAX:</p><pre class="programlisting">#!/usr/bin/perl -w
use XML::LibXML::SAX::Parser;
use XML::Handler::PrintEvents;
my $p = XML::LibXML::SAX::Parser-&gt;new(Handler =&gt; XML::Handler::PrintEvents-&gt;new);
$p-&gt;parse_uri("sidebar.xml");</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2462962"></a>DOM</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2462966"></a>Validación</h3></div></div></div><p>El procesador DOM de <code class="classname">LibXML::XML</code> puede validar documentos XML contra un
DTD en tiempo de procesamiento. Por defecto hemos visto que no lo hace, pero podemos
cambiar esta conducta habilitando la validación con el método
<code class="methodname">validation</code>.</p><p>Es posible no obstante validar el documento después de procesado. Este sistema se aplica tanto a DTDs como a RelaxNG y esquemas XML.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2462996"></a>DTDs</h4></div></div></div><p>Estos procediemtos se aplican a los objetos del tipo <span class="type">XML::LibXML::Document</span>, es decir al árbol DOM completo obtenido tras el procesamiento con alguno de los métodos adecuados DOM, por ejemplo <code class="methodname">parse_file</code>.</p><div class="itemizedlist"><ul type="disc"><li><p>Con el método <code class="methodname">validate</code></p><p>En este caso debemos procesar adicionalmente el DTD. El método <code class="methodname">new</code> de
<a href="http://search.cpan.org/perldoc?XML::LibXML::Dtd" target="_top">XML::LibXML::Dtd</a>
nos devuelve un objeto DOM de la clase <code class="classname">XML::LibXML::Dtd</code>, un tipo especial de
<code class="classname">XML::LibXML::Node</code>. El utilizar un módulo aparte para el procesamiento de los DTDs
es necesario, porque recordemos que los DTDs no son documentos válidos XML.</p><p>Y después llamamos al método <code class="methodname">validate</code> del
objeto <span class="type">Document</span> que representa el documento XML:</p><pre class="programlisting">use XML::LibXML;
my $parser = XML::LibXML-&gt; new();
my $doc = $parser-&gt;parse_file("sidebar.xml");

my $dtd = XML::LibXML::Dtd-&gt;new(
                      "-//AxKit//DTD Sidebar XML V1.0//EN",
                      "sidebar.dtd"
                                );
$doc-&gt;validate($dtd);</pre><p>El método <code class="methodname">new</code> de <code class="classname">XML::LibXML::Dtd</code> recibe como parámetros el identificador público del DTD y el nombre del archivo que lo contiene. Si el DTD lo guardamos como una cadena de texto, en un escalar, utilizaremos el método alternativo <code class="methodname">parse_string</code>:</p><pre class="programlisting">my $dtd = XML::LibXML::Dtd-&gt;parse_string($mydtd);</pre></li><li><p>Con el método <code class="methodname">is_valid</code></p><p>Desde el objeto <code class="classname">XML::LibXML::Document</code> se puede utilizar otro método alternativo, <code class="methodname">is_valid</code>, que devuelve un valor booleano con el resultado. Si no hay otro camino anterior para que el procesador sepa del archivo que contiene el DTD, se lo podemos inclir como parámetro:</p><pre class="programlisting">my $doc = $parser-&gt;parse_file("sidebar.xml");
if (!$doc-&gt;is_valid("sidebar.dtd")) {
       warn("document is not valid!");
   }</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2463132"></a>RelaxNG</h4></div></div></div><p>El procedimiento de validación de un documento contra un esquema <a href="http://www.relaxng.org/" target="_top">RelaxNG</a> difiere en algo de la validación contra DTDs, que son el procesamiento por defecto en <code class="classname">XML::LibXML</code>, y que son los definidos en el estandard.</p><p>El paso inicial del procesamiento del documento XML es igual que en caso anterior. El procesamiento del esquema RelaxNG lo lleva a cabo el módulo <code class="classname">XML::LibXML::RelaxNG</code>, y el método <code class="methodname">validate</code> que lleva a cabo la acción final de validación en esta ocasión lo provee este últmo módulo. </p><pre class="programlisting">use XML::LibXML;
my $parser = XML::LibXML-&gt; new();
my $validator = XML::LibXML::RelaxNG-&gt;new(location =&gt; "prueba.rng");
my $doc = $parser-&gt; parse_file("prueba.xml");
eval { $validator-&gt; validate($doc); };</pre><p>Podemos probar este código con los ejemplos que nos ofrece el <a href="http://www.oasis-open.org/committees/relax-ng/tutorial.html" target="_top">tutorial</a> de RelaxNG que nos proporcionan sus desarrolladores.</p><p>El método <code class="methodname">new</code> el validador recibe como parámetro un par clave-valor que indica el tipo de datos en que se guarda el esquema RelaxNG y dónde ha de irlo a buscar el programa. Las opciones posibles en los tipos de datos son:</p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>location</code></em>, un archivo físico</p></li><li><p><em class="parameter"><code>string</code></em>, un escalar con el texto XML correspondiente</p></li><li><p><em class="parameter"><code>DOM</code></em>, un objeto del tipo <code class="classname">XML::LibXML::Document</code>
que representa el esquema RelaxNG, generado previamente por el procesador</p></li></ul></div><p>Así, la creación de la instancia del validador con <code class="option">string</code> podría ser:</p><pre class="programlisting">my $validator = XML::LibXML::RelaxNG-&gt;new(string =&gt;
&lt;&lt;'FIN');
&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;
FIN;</pre><p>Y con DOM debemos procesar previamente el esquema RelaxNG, que es después de todo un documento XML:</p><pre class="programlisting">my $rng=$parser-&gt; parse_file("prueba.rng");
my $validator = XML::LibXML::RelaxNG-&gt;new(DOM =&gt; $rng);;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2463268"></a>Esquemas XML</h4></div></div></div><p>El tratamiento para <a href="http://www.w3.org/XML/Schema" target="_top">esquemas XML</a> es similar al de RelaxNG, haciendo uso de un validador de la clase <code class="classname">XML::LibXML::Schema</code>. Esta vez sólo disponemos de dos opciones para entregar el código del esquema, la de un archivo y un escalar:</p><pre class="programlisting">use XML::LibXML;
my $parser = XML::LibXML-&gt; new();
my $validator = XML::LibXML::Schema-&gt;new(location =&gt; "library1.xsd");
my $doc = $parser-&gt; parse_file("library1.xml");
eval { $validator-&gt; validate($doc); };</pre><p>Podemos comprobar este código con los ejemplos de un tutorial de <a href="http://www.xml.com/pub/a/2000/11/29/schemas/part1.html" target="_top">xml.com</a>.</p><p>Si se tratara de un escalar, el comportamiento es igual al que vimos más arriba:</p><pre class="programlisting">my $validator = XML::LibXML::Schema-&gt;new(string =&gt;$myXMLschema);</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2463323"></a>Clases</h3></div></div></div><p>DOM incluye ahora varios conjuntos de interfaces. <code class="classname">LibXML::XML</code> implementa tan sólo un subconjunto de los interfaces del <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/idl-definitions.html" target="_top">Core</a> de DOM. En lo que respecta a los que regulan la <a href="http://www.w3.org/TR/2004/NOTE-DOM-Level-3-XPath-20040226/idl-definitions.html" target="_top">integración con XPath</a>, la creación de documentos XML, y la <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/idl-definitions.html" target="_top">validación</a>, libxml2 había implementado soluciones específicas bastante antes de que se formalizaran estos estándares, que tienen algo más de un año de antigüedad, por lo que <code class="classname">LibXML::XML</code> ofrece soluciones bien diferentes. Libxml2 también provee desde hace tiempo de algunas extensiones de salida, mientras ahora las operaciones de entrada y salida se inscriben en el estándard en la especificación <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/idl-definitions.html" target="_top">Load and Save</a>, con un planteamiento bien diferente.</p><p>En lo que respecta a la especificación Core de DOM, <code class="classname">LibXML::XML</code> no implementa todos los interfaces; en especial faltan todos los añadidos en el nivel 3, aunque los que sí tienen cabida en libxml2 han sido actualizados en muchos de sus métodos a los niveles 2 y 3 de DOM. </p><p>En general, <code class="classname">LibXML::XML</code> tiende a cubrir los interfaces DOM que forman la representación en árbol. DOM representa a XML como un conjunto jerárquico de objetos <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1950641247" target="_top"><code class="interfacename">Node</code></a>. De esta clase básica
se derivan las subclases <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#i-Document" target="_top"><code class="interfacename">Document</code></a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-B63ED1A3" target="_top"><code class="interfacename">DocumentFragment</code></a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-412266927" target="_top"><code class="interfacename">DocumentType</code></a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-11C98490" target="_top"><code class="interfacename">EntityReference</code></a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-745549614" target="_top"><code class="interfacename">Element</code></a>
, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-637646024" target="_top"><code class="interfacename">Attr</code></a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1004215813" target="_top"><code class="interfacename">ProcessingInstruction</code></a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1728279322" target="_top"><code class="interfacename">Comment</code></a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1312295772" target="_top"><code class="interfacename">Text</code></a>,<a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-667469212" target="_top"> CDATASection</a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-527DCFF2" target="_top"><code class="interfacename">Entity</code></a> y <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-5431D1B9" target="_top"><code class="interfacename">Notation</code></a>.</p><p>XML::LibXML provee también clases correspondientes a los interfaces DOM que son colecciones de sus objetos: <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-536297177" target="_top"><code class="interfacename">NodeList</code></a> y <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-536297177" target="_top"><code class="interfacename">NamedNodeMap</code></a>.</p><p>La siguiente tabla muestra la correspondencia entre los interfaces DOM y las clases correspondientes de <code class="classname">XML::LibXML</code>.</p><div class="table"><a name="id2463550"></a><p class="title"><b>Table 3. Implementación de los interfaces DOM y extensiones</b></p><table summary="Implementación de los interfaces DOM y extensiones" border="1"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><p>Interfaz DOM</p></th><th align="left"><p>Nivel</p></th><th align="left"><p>Clase XML::LibXML</p></th></tr></thead><tbody><tr><td align="left"><p>Attr</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::Attr</p></td></tr><tr><td align="left"><p>CDATASection</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::CDATASection</p></td></tr><tr><td align="left"><p>CharacterData</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>Comment</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::Comment</p></td></tr><tr><td align="left"><p>Document</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::Document</p></td></tr><tr><td align="left"><p>DocumentFragment</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::DocumentFragment</p></td></tr><tr><td align="left"><p>DocumentType</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::Dtd</p></td></tr><tr><td align="left"><p>DOMConfiguration</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>DOMError</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>DOMErrorHandler</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>DOMImplementation</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>DOMImplementationList</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>DOMImplementationSource</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>DOMLocator</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>DOMStringList</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>Element</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::Element</p></td></tr><tr><td align="left"><p>Entity</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>EntityReference</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>NamedNodeMap</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::NamedNodeMap</p></td></tr><tr><td align="left"><p>NameList</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>Node</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::Node</p></td></tr><tr><td align="left"><p>NodeList</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::NodeList</p></td></tr><tr><td align="left"><p>Notation</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>ProcessingInstruction</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::PI</p></td></tr><tr><td align="left"><p>Text</p></td><td align="left"><p>1</p></td><td align="left"><p>XML::LibXML::Text </p></td></tr><tr><td align="left"><p>TypeInfo</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>UserDataHandler</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left"><p>XML::LibXML::Namespace</p></td></tr></tbody></table></div><p>En <code class="classname">XML::LibXML</code> no poseemos acceso directo a las propiedades de los objetos DOM. En su lugar contamos con métodos de lectura o escritura de estas propiedades.</p><p>La referencia al nivel DOM en la tabla anterior indica el que describió por primera vez el interfaz, aunque haya sido modificado por versiones posteriores. Para los interfaces implementados ya indicaremos el nivel de DOM utilizado en cada atributo y operación.</p><p>Destacan algunas peculiaridades de la implementación DOM de <code class="classname">XML::LibXML</code>:</p><div class="itemizedlist"><ul type="disc"><li><p>No hay una implementación para el interfaz <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Interfaces-DOMLocator" target="_top"><code class="interfacename">DomLocator</code></a>, que permite establecer con precisión referencias de localización textual (fila, columna,...), típicamente usadas en descripción de errores de las tareas de procesado o validación. En <code class="classname">LibXML::XML</code> contamos tan sólo con un método <code class="methodname">line_number</code> de la clase <code class="classname">LibXML::XML::Node</code>, que indica el número de línea en que se sitúa el nodo. El subsistema de errores de libxml2, accesible desde los métodos tradicionales de captura de error de Perl, ofrece información adicional sobre la posición, así como la naturaleza del error. En caso de error no se siguen las directrices de los interfaces <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ERROR-Interfaces-DOMError" target="_top"><code class="interfacename">DomError</code></a> y <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ERROR-Interfaces-DOMErrorHandler" target="_top"><code class="interfacename">DomErrorHandler</code></a>.</p></li><li><p>XML::LibXML no tiene un interfaz <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-FF21A306" target="_top"><code class="interfacename">CharacterData</code></a> como base para los interfaces de texto,y en su lugar los modela desde la clase <code class="classname">XML::LibXML::Text</code>.</p></li><li><p>No hay en <code class="classname">LibXML::XML</code> una clase correspondiente con los interfaces DOM <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-527DCFF2" target="_top"><code class="interfacename">Entity</code></a>, <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-11C98490" target="_top"><code class="interfacename">EntityReference</code></a> o <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-5431D1B9" target="_top"><code class="interfacename">Notation</code></a>: Para tratarlos se utilizan directamente elementos <code class="classname">XML::LibXML::Node</code>. Por tanto no se posee como en los otros casos un método <code class="methodname">new</code> para su creación, y debe acudirse alternativamente a los métodos correspondientes de la clase del nodo superior, <code class="classname">XML::LibXML::Document</code>. Internamente las operaciones reconocen el tipo de nodo.</p></li><li><p>La clase <code class="classname">XML::LibXML::NameSpace</code> no forma parte de DOM, es una extensión al modelo efectuada por libxml2.</p></li><li><p><code class="classname">XML::LibXML</code> no implementa una clase para el interfaz DOM <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-412266927" target="_top"><code class="interfacename">DocumentType</code></a>. En su lugar ofrece una clase más compleja, <code class="classname">XML::LibXML::Dtd</code>, que puede albergar como hijos todos los elementos del DTD completo, no limitándose a la declaración.</p></li><li><p>No hay una implementación para el interfaz DOM <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-102161490" target="_top"><code class="interfacename">DOMImplementation</code></a>, pero los métodos <code class="methodname">new</code> y <code class="methodname">createDocument</code> de <code class="classname">LibXML::XML</code> proveen de la operación de aquél, <code class="methodname">CreateDocument</code>.</p></li></ul></div><p>Las discrepancias entre DOM y <code class="classname">LibXML::XML</code> pueden entenderse mejor si observamos el modelo desde la perspectiva de libxml2.</p><p>DOM piensa el documento XML como un conjunto de nodos, de los que describe 12 tipos distintos, tal como vemos en la propiedad nodeType del interfaz Node. Estos nodos son los que constituyen el árbol DOM en sí.</p><p>Pero la <a href="http://dev.w3.org/cvsweb/XML/tree.h" target="_top">implementación de libxml2</a> en cambio ve 21 tipos de nodos diferentes:</p><div class="table"><a name="id2464264"></a><p class="title"><b>Table 4. Tipos de Nodos en DOM y en libxml2</b></p><table summary="Tipos de Nodos en DOM y en libxml2" border="1"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><p>Nodos DOM</p></th><th align="left"><p>Nodos libxml2</p></th><th align="left"><p>NodeType</p></th></tr></thead><tbody><tr><td align="left"><p>Node</p></td><td align="left"><p>XML_ELEMENT_NODE</p></td><td align="left"><p>1</p></td></tr><tr><td align="left"><p>Attribute</p></td><td align="left"><p>XML_ATTRIBUTE_NODE</p></td><td align="left"><p>2</p></td></tr><tr><td align="left"><p>Text</p></td><td align="left"><p>XML_TEXT_NODE</p></td><td align="left"><p>3</p></td></tr><tr><td align="left"><p>CDATASection</p></td><td align="left"><p>XML_CDATA_SECTION_NODE</p></td><td align="left"><p>4</p></td></tr><tr><td align="left"><p>EntityReference</p></td><td align="left"><p>XML_ENTITY_REF_NODE</p></td><td align="left"><p>5</p></td></tr><tr><td align="left"><p>Entity</p></td><td align="left"><p>XML_ENTITY_NODE</p></td><td align="left"><p> 6</p></td></tr><tr><td align="left"><p>ProcessingInstruction</p></td><td align="left"><p>XML_PI_NODE</p></td><td align="left"><p>7</p></td></tr><tr><td align="left"><p>Comment</p></td><td align="left"><p>XML_COMMENT_NODE</p></td><td align="left"><p>8</p></td></tr><tr><td align="left"><p>Document</p></td><td align="left"><p>XML_DOCUMENT_NODE</p></td><td align="left"><p> 9</p></td></tr><tr><td align="left"><p>DocumentType</p></td><td align="left"><p>XML_DOCUMENT_TYPE_NODE</p></td><td align="left"><p>10</p></td></tr><tr><td align="left"><p>DocumentFragment</p></td><td align="left"><p>XML_DOCUMENT_FRAG_NODE</p></td><td align="left"><p>11</p></td></tr><tr><td align="left"><p>Notation</p></td><td align="left"><p>XML_NOTATION_NODE</p></td><td align="left"><p> 12</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_HTML_DOCUMENT_NODE</p></td><td align="left"><p>13</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_DTD_NODE</p></td><td align="left"><p> 14</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_ELEMENT_DECL</p></td><td align="left"><p>15</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_ATTRIBUTE_DECL</p></td><td align="left"><p>16</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_ENTITY_DECL</p></td><td align="left"><p> 17</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_NAMESPACE_DECL</p></td><td align="left"><p>18</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_XINCLUDE_START</p></td><td align="left"><p>19</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_XINCLUDE_END</p></td><td align="left"><p>20</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p>XML_DOCB_DOCUMENT_NODE</p></td><td align="left"><p>21</p></td></tr></tbody></table></div><p>Dos de los añadidos señalan los nodos Document en textos no XML que puede tratar libxml2, la raíz de los documentos HTML y Docbook SGML. Otros dos indican los puntos de anclaje de los elementos Xinclude.</p><p>El nodo <span class="type">DocumentType</span> es obsoleto, y se mantiene por compatibilidad con DOM, pero de hecho está sustituido por el nodo <span class="type">Dtd</span>. Para los componentes del DTD se han añadido los 5 tipos restantes.</p><p>La mayoría de estos tipos de nodos han sido pasados a clases por <code class="classname">XML::LibXML</code>, pero no en todos los casos. Si no se ha establecido una clase, libxml2 los reconocerá, pero los trataremos desde <code class="classname">XML::LibXML::Node</code>, o desde los métodos que les correspondan en los nodos raíz o ramas de DOM, Document o Element.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2464705"></a><code class="classname">Node</code></h4></div></div></div><p>Node es el interfaz base del Core de DOM. DOM modela los documentos XML como un conjunto de nodos. Veamos la corespondencia entre el interfaz y su implementación con <code class="classname">XML::LibXML::Node</code>.</p><div class="table"><a name="id2464723"></a><p class="title"><b>Table 5. Interfaz DOM Node y clase XML::LibXML::Node</b></p><table summary="Interfaz DOM Node y clase XML::LibXML::Node" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><p>Tipo</p></th><th align="left"><p>Nombre</p></th><th align="left"><p>RW</p></th><th align="left"><p>Nivel</p></th><th align="left"><p>Método</p></th></tr></thead><tbody><tr><td align="left"><p>attr</p></td><td align="left"><p>attributes</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>attributes</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>baseURI</p></td><td align="left"><p>R</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>childNodes</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>childNodes</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>firstChild</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>firstChild</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>lastChild</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>lastChild</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>localName</p></td><td align="left"><p>R</p></td><td align="left"><p>2</p></td><td align="left"><p>localname</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>namespaceURI</p></td><td align="left"><p>R</p></td><td align="left"><p>2</p></td><td align="left"><p>namespaceURI</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>nextSibling</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>nextSibling</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>nodeName</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>nodeName - setNodeName</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>nodeType</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>nodeType</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>nodeValue</p></td><td align="left"><p>RW</p></td><td align="left"><p>1</p></td><td align="left"><p>nodeValue</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>ownerDocument</p></td><td align="left"><p>R</p></td><td align="left"><p>1-2</p></td><td align="left"><p>ownerDocument - setOwnerDocument</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>parent</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>parentNode</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>prefix</p></td><td align="left"><p>RW</p></td><td align="left"><p>2</p></td><td align="left"><p>prefix</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>previousSibling</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>previousSibling</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>textContent</p></td><td align="left"><p>RW</p></td><td align="left"><p>3</p></td><td align="left"><p>textContent</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>appendChild</p></td><td align="left"><p></p></td><td align="left"><p>-3</p></td><td align="left"><p>appendChild</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>clone</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>cloneNode</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>compareDocumentPosition</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getFeature</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getUserData</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>hasAttributes</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>hasAttributes</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>hasChildNodes</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>hasChildNodes</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>insertBefore</p></td><td align="left"><p></p></td><td align="left"><p>1-3</p></td><td align="left"><p>insertBefore</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>isDefaultNamespace</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>isEqual</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td align="left"><p>isEqual</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>isSame</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td align="left"><p>isSameNode</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>isSupported</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>lookupNamespaceURI</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td align="left"><p>lookupNamespaceURI</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>lookupPrefix</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>normalize</p></td><td align="left"><p></p></td><td align="left"><p>2-3</p></td><td align="left"><p>normalize</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>removeChild</p></td><td align="left"><p></p></td><td align="left"><p>1-3</p></td><td align="left"><p>removeChild</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>replaceChild</p></td><td align="left"><p></p></td><td align="left"><p>1-3</p></td><td align="left"><p>replaceChild</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setUserData</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>addChild</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>addNewChild</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>addSibling</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>getNamespaces</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>getOwner</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>insertAfter</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>removeChildNodes</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>replaceNode</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>unbindNode</p></td></tr></tbody></table></div><p>Para su uso típico en escritura de documentos, <code class="classname">LibXML::XML</code> provee de un método de escritura para el atributo NodeName del estándard DOM, que no contempla este caso, <code class="methodname">setNodeName</code>. Tengamos en cuenta que DOM sigue caminos diferentes en la creación de documentos XML.</p><p>Otra diferencia con el estándard es el atributo <code class="varname">baseURI</code>, que DOM modela dentro de <code class="interfacename">Node</code>. Hemos visto que es un parámetro global en <code class="classname">XML::LibXML</code>, pasado al procesador, por lo que ni siquiera está a la altura del nodo raíz del documento XML, sino afectado a todos los documentos pasados al procesador.</p><p>El interfaz <code class="interfacename">Node</code> del estandard DOM provee de una propiedad de sólo lectura, <code class="varname">ownerDocument</code>, que indica el nodo de tipo <code class="interfacename">Document</code> que ocupa el lugar más alto de la estructura arbórea XML. Tal valor será nulo cuando se crea un nodo por primera vez. <code class="classname">LibXML::XML</code>, por contra, provee de dos métodos para esta propiedad, uno de lectura, <code class="methodname">ownerDocument</code>, y otro de escritura, <code class="methodname">setOwnerDocument</code>, lo que de hecho nos permite sacar un nodo de un documento e incluirlo en otro.</p><p>Esta operación ya la permite DOM 3, pero efectuada desde el nodo superior, <code class="interfacename">Document<code class="interfacename"></code></code>, mediante la operación <code class="methodname">adoptNode</code>. Lo que hace <code class="classname">LibXML::XML</code> es permitir también la operación desde el nodo inferior. Las dos últimas líneas del siguiente código son similares:</p><pre class="programlisting">my $doc = XML::LibXML::Document-&gt;new;
my $xnode = XML::LibXML::Element-&gt;new("test");

my $node = $doc-&gt;adoptNode( $xnode );
$xnode-&gt;setOwnerDocument( $doc );</pre><p>Adicionalmente, <code class="classname">LibXML::XML</code> permite adscribir nodos no sólo a documentos, sino también a fragmentos  -nodos <code class="interfacename">DocumentFragment</code>-. De ahí que provee de un método para averiguar directamente el nodo superior, <code class="methodname">getOwner</code>, sin hacer referencia explícita al nodo <code class="classname">XML::LibXML::Document</code>. Su efecto no obstante es similar al método <code class="methodname">ownerDocument</code> si efectivametne el nodo está adscrito a un documento.</p><p><code class="classname">XML::LibXML</code> extiende las operaciones del estándard DOM en la manipulación de nodos con métodos de adición (<code class="methodname">addChild</code>, <code class="methodname">addNewChild</code>, <code class="methodname">addSibling</code>, <code class="methodname">insertAfter</code>), substracción (<code class="methodname">removeChildNodes</code>) o sustitución (<code class="methodname">replaceNode</code>).</p><p>En lo que se refiere a los enlaces directos de los nodos, <code class="classname">LibXML::XML</code> provee de un método, <code class="methodname">unbindNode</code>, que desliga el nodo de sus superiores y hermanos; la adscripción al nodo documento sin embargo no se pierde, y deberemos acudir a <code class="methodname">setOwnerDocument</code> si deseamos cambiarlo de documento. Los nodos desligados son implícitamente hijos de un nodo <code class="classname">XML::LibXML::DocumentFragment</code>.</p><p>Otra extensión a DOM es el método <code class="methodname">getNamespaces</code>, que devuelve los espacios de nombres declarados explícitamente en ese nodo (no los heredados desde los nodos superiores). Este método devuelve un arreglo de objetos <code class="classname">XML::LibXML::Namespace</code>.</p><p><code class="classname">XML::LibXML::Node</code> ofrece métodos adicionales para búsquedas XPath y salida, a los que nos referiremos más tarde.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2466018"></a><code class="classname">NodeList</code></h4></div></div></div><p>DOM define el interfaz <code class="interfacename">Nodelist</code> como una simple lista ordenada de nodos, sin entrar a detallar su implementación. Tan sólo indica dos propiedades que describen el número de items (<code class="varname">length</code>) y los nodos componentes (<code class="varname">item</code>).</p><p><code class="classname">XML::LibXML</code> permite utilizar las lista de nodos como arreglos de Perl, con cualquiera de sus procedimientos habituales. El siguiente ejemplo nos devolverá por este camino el número de elementos de la lista, que presentaremos seguidamente como cadenas de texto:</p><pre class="programlisting">use XML::LibXML;

my $string = "&lt;A&gt;&lt;A&gt;&lt;B/&gt;&lt;/A&gt;&lt;A&gt;&lt;B/&gt;&lt;/A&gt;&lt;/A&gt;";
my $parser = XML::LibXML-&gt;new();
my $document = $parser-&gt;parse_string($string);
my @array = $document-&gt;getElementsByTagName("A");
print scalar( @array ), "\n";
foreach $node (@array) {
	print $node-&gt;toString, "\n";
}</pre><p>Lo que devolverá el número de elementos, y cada uno de los nodos, como texto:</p><pre class="screen">3
&lt;A&gt;&lt;A&gt;&lt;B/&gt;&lt;/A&gt;&lt;A&gt;&lt;B/&gt;&lt;/A&gt;&lt;/A&gt;
&lt;A&gt;&lt;B/&gt;&lt;/A&gt;
&lt;A&gt;&lt;B/&gt;&lt;/A&gt;</pre><p><code class="classname">XML::LibXML</code> provee también de una implementación específica del interfaz <code class="interfacename">Nodelist</code>, <a href="http://search.cpan.org/perldoc?XML::LibXML::Nodelist" target="_top"><code class="classname">XML::LibXML::Nodelist</code></a>. Esta clase funciona de manera bastante similar a un arreglo Perl, con métodos para crear un objeto (<code class="methodname">new</code>), introducir elementos en él (<code class="methodname">push</code> como en una pila, <code class="methodname">unshift</code> como en colas), extraerlos (<code class="methodname">pop</code> como en pilas, <code class="methodname">shift</code> como en colas) y para conocer el número de elementos (<code class="methodname">size</code>, equivalente a la propiedad <code class="varname">lenght</code> del interfaz).</p><p>Si utilizamos la clase <a href="http://search.cpan.org/perldoc?XML::LibXML::Nodelist::Iterator" target="_top"><code class="classname">XML::LibXML::Nodelist::Iterator</code></a>, externa a la distribución, dispondremos de un método adicional, <code class="methodname">iterator</code>, que nos permite crear subconjuntos de <code class="classname">XML::LibXML::Nodelist</code> que cumplan determinada condición XPath y tratarlos como una lista, con movimientos lineales hacia arriba y hacia abajo.</p><p>Los métodos de la clase <code class="classname">XML::LibXML::Document</code> que devuelven listas de nodos si se utilizan en contexto de arreglos, como en el ejemplo anterior, devuelven arreglos Perl, pero si se utilizan en contexto escalar devuelven un objeto <code class="classname">XML::LibXML::Nodelist</code>.</p><p>Podemos modificar ligeramente el ejemplo anterior, para conocer desde un objeto <code class="classname">XML::LibXML::Nodelist</code> su número de elementos, y que nos devuelva el último:</p><pre class="programlisting">use XML::LibXML;

my $string = "&lt;A&gt;&lt;A&gt;&lt;B/&gt;&lt;/A&gt;&lt;A&gt;&lt;B/&gt;&lt;/A&gt;&lt;/A&gt;";
my $parser = XML::LibXML-&gt;new();
my $document = $parser-&gt;parse_string($string);
my $nodelist = $document-&gt;getElementsByTagName("A");
print $nodelist-&gt;size, "\n";
my $node=$nodelist-&gt;pop;
print $node-&gt;toString;</pre><p>Obtendremos:</p><pre class="screen">3
&lt;A&gt;&lt;B/&gt;&lt;/A&gt;</pre><p>Los métodos <code class="methodname">prepend</code> y <code class="methodname">append</code> nos permiten añadir un objeto <code class="classname">XML::LibXML::Nodelist</code> a otro ya existente, colocándolo al principio o al final respectivamente.</p><p>Modificamos nuestro ejemplo para que añada un nuevo Nodelist al que hemos creado inicialmente, al final del conjunto existente:</p><pre class="programlisting">my $nodelist2 = $document-&gt;getElementsByTagName("B");
$nodelist-&gt;append($nodelist2);</pre><p>y el resultado mostrará los cambios introducidos tras la adición del nuevo objeto <code class="classname">XML::LibXML::Nodelist</code>:</p><pre class="screen">5
&lt;B/&gt;</pre><p>El método <code class="methodname">get_nodelist</code> devuelve un arreglo Perl, con lo que podremos revertir al modelo de gestión de listas de nodos que veíamos arriba. </p><p>Añadiendo estas lineas al ejemplo anterior:</p><pre class="programlisting">my @array=$nodelist-&gt;get_nodelist;
print scalar( @array ), "\n";</pre><p>nos devolverá el número de elementos del arreglo que hemos creado con los nodos que contiene el objeto <code class="classname">XML::LibXML::Nodelist</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2466272"></a><code class="classname">NamedNodeMap</code></h4></div></div></div><p>La interfaz <code class="interfacename">NamedNodeMap</code> permite acceder a colecciones de nodos, pero a diferencia de <code class="interfacename">Nodelist</code> los nodos están agrupados por su nombre, y no están ordenados.</p><div class="table"><a name="id2466291"></a><p class="title"><b>Table 6. Interfaz DOM NamedNodeMap y clase XML::LibXML::NamedNodeMap</b></p><table summary="Interfaz DOM NamedNodeMap y clase XML::LibXML::NamedNodeMap" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><p>Tipo</p></th><th align="left"><p>Nombre</p></th><th align="left"><p>RW</p></th><th align="left"><p>Nivel</p></th><th align="left"><p>Método</p></th></tr></thead><tbody><tr><td align="left"><p>attr</p></td><td align="left"><p>length</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>length</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getNamedItem</p></td><td align="left"> </td><td align="left"><p>1</p></td><td align="left"><p>getNamedItem</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getNamedItemNS</p></td><td align="left"> </td><td align="left"><p>2</p></td><td align="left"><p>getNamedItemNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>item</p></td><td align="left"> </td><td align="left"><p>1</p></td><td align="left"><p>item </p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>removeNamedItem</p></td><td align="left"> </td><td align="left"><p>1</p></td><td align="left"><p>removeNamedItem</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>removeNamedItemNS</p></td><td align="left"> </td><td align="left"><p>2</p></td><td align="left"><p>removeNamedItemNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setNamedItem</p></td><td align="left"> </td><td align="left"><p>1</p></td><td align="left"><p>setNamedItem</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setNamedItemNS</p></td><td align="left"> </td><td align="left"><p>2</p></td><td align="left"><p>setNamedItemNS</p></td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left"> </td><td align="left"> </td><td align="left"><p>new</p></td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left"> </td><td align="left"> </td><td align="left"><p>nodes</p></td></tr><tr></tr></tbody></table></div><p>El método <code class="methodname">attributes</code> de <code class="classname">XML::LibXML::Node</code> devuelve en contexto escalar un nodo <code class="classname">XML::LibXML::NamedNodeMap</code> (en contexto de arreglo devuelve un arreglo Perl de objetos <code class="classname">XML::LibXML::Attr</code>):</p><pre class="programlisting">use XML::LibXML;
my $string = '&lt;a n="1" b="c"&gt;&lt;b/&gt;&lt;/a&gt;';
my $parser = XML::LibXML-&gt;new();
my $doc= $parser-&gt;parse_string($string);

my $nnm=$doc-&gt;firstChild-&gt;attributes;
print $nnm-&gt;length;</pre><p>El método <code class="methodname">length</code> devuelve el número de nodos que componen la colección. El método <code class="methodname">new</code> que introduce <code class="classname">XML::LibXML::NamedNodeMap</code> permite crear un objeto nuevo, a partir de un arreglo de nodos:</p><pre class="programlisting">use XML::LibXML;
my $string = '&lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;d/&gt;&lt;/a&gt;';
my $parser = XML::LibXML-&gt;new();
my $doc= $parser-&gt;parse_string($string);
my @array=($doc-&gt;firstChild-&gt;firstChild, $doc-&gt;firstChild-&gt;lastChild);
my $nnm=XML::LibXML::NamedNodeMap-&gt;new(@array);
print $nnm-&gt;getNamedItem("d")-&gt;toString;</pre><p>El uso habitual de esta colección de nodos es a través de su nombre. En este ejemplo, el método <code class="methodname">getNamedItem</code> nos devuelve el nodo correspondiente a un nombre que conocemos previamente.</p><p>El método <code class="methodname">nodes</code>, también extensión de <code class="classname">XML::LibXML::NamedNodeMap</code> a DOM, permite realizar la operación contraria a <code class="methodname">new</code>, o sea obtener un arreglo de nodos a partir de un objeto <code class="classname">XML::LibXML::NamedNodeMap</code>. <code class="methodname">nodes</code> en realidad devuelve una referencia a un arreglo. Así, si el objeto <code class="classname">XML::LibXML::NamedNodeMap</code> anterior se convierte en una colección ordenada, podemos acceder a ella secuencialmente:</p><pre class="programlisting">my $new_array= $nnm-&gt;nodes;
foreach $node ( @{$new_array} ) {   
    print $node-&gt;toString , "\n";
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2466695"></a><code class="classname">Document</code></h4></div></div></div><p><code class="interfacename">Document</code> y <code class="interfacename">DocumentFragment</code> son los nodos más altos en la jerarquía que establece el modelo DOM para representar los textos XML. Todos los demás nodos serán hijos de estos nodos. En consecuencia, el procesador DOM de <code class="classname">LibXML::XML</code> devuelve objetos de estos tipos tras tratar un texto de entrada.</p><div class="table"><a name="id2466722"></a><p class="title"><b>Table 7. Interfaz DOM Document y clase XML::LibXML::Document</b></p><table summary="Interfaz DOM Document y clase XML::LibXML::Document" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><p>Tipo</p></th><th align="left"><p>Nombre</p></th><th align="left"><p>RW</p></th><th align="left"><p>Nivel</p></th><th align="left"><p>Método</p></th></tr></thead><tbody><tr><td align="left"><p>attr</p></td><td align="left"><p>doctype</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>documentElement</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td align="left"><p>documentElement - setDocumentElement</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>documentURI</p></td><td align="left"><p>RW</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>domConfig</p></td><td align="left"><p>R</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>implementation</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>inputEncoding</p></td><td align="left"><p>R</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>strictErrorChecking</p></td><td align="left"><p>RW</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>xmlEncoding</p></td><td align="left"><p>R</p></td><td align="left"><p>3</p></td><td align="left"><p>encoding - setEncoding</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>xmlStandalone</p></td><td align="left"><p>RW</p></td><td align="left"><p>3</p></td><td align="left"><p>standalone - setStandalone</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>xmlVersion</p></td><td align="left"><p>RW</p></td><td align="left"><p>3</p></td><td align="left"><p>version</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>adoptNode</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td align="left"><p>adoptNode</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createAttribute</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>createAttribute</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createAttributeNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>createAttributeNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createCDATASection</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>create</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createComment</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>createComment</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createDocumentFragment</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>createDocumentFragment</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createElement</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>createElement</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createElementNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>createElementNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createEntityReference</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>createEntityReference</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createProcessingInstruction</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>createProcessingInstruction</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>createTextNode</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>createTextNode</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getElementById</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getElementsByTagName</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>getElementsByTagName</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getElementsByTagNameNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>getElementsByTagName</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>importNode</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>importNode</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>normalize</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>renameNode</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>compression</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>createDocument | new</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>createExternalSubset</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>createInternalSubset</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>externalSubset</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>getElementsById</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>getElementsByLocalName</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>indexElements</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>insertProcessingInstruction</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>internalSubset</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>removeExternalSubset</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>removeInternalSubset</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>setCompression</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>setExternalSubset</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>setInternalSubset</p></td></tr></tbody></table></div><p>Si no hemos utilizado el procesador, y deseamos crear un objeto <a href="http://search.cpan.org/perldoc?XML::LibXML::Document" target="_top">XML::LibXML::Document</a> nuevo, debemos partir del método <code class="methodname">createDocument</code> o su alias new.</p><p>XML::LibXML añade dos extensiones adicionales a las operaciones que permiten obtener listas de nodos desde el nodo documento: <code class="methodname">getElementsById</code> y <code class="methodname">getElementsByLocalName</code>.</p><p><code class="classname">XML::LibXML</code> permite compresión, y por ello añade los métodos <code class="methodname">compression</code> y <code class="methodname">setCompression</code> a los nodos Document; se trata de la manipulación de una propiedad, y obviamente no afecta al árbol DOM, sino a las operaciones de escritura que se se realicen posteriormente con él.</p><p>DOM establece una única propiedad, <code class="varname">doctype</code>, de sólo lectura, para indicar el tipo de documento (interfaz <code class="interfacename">DocType</code>). <code class="classname">LibXML::XML</code> en cambio utiliza la clase <code class="classname">XML::LibXML::Dtd</code> para representar el tipo de documento.</p><p>libxml2 distingue entre nodos <span class="type">Dtd</span> internos y externos: los internos son procesados como paso previo a su utilización; de ahí que los métodos de adscripción genéricos de <code class="interfacename">Document</code> (<code class="methodname">adoptNode</code>, <code class="methodname">importNode</code>), no son suficientes para este tipo de nodos. En su lugar se ofrece un grupo extenso de métodos para actuar sobre este tipo de nodos desde el nivel superior del árbol (<code class="classname">XML::LibXML::Document</code>), además de los que provee la clase <code class="classname">XML::LibXML::Dtd</code> en el nivel inferior. Se proveen para crear (<code class="methodname">createDTD</code>, <code class="methodname">createExternalSubset</code>, <code class="methodname">createInternalSubset</code>), indicar cuál se aplica (<code class="methodname">setExternalSubset</code>, <code class="methodname">setInternalSubset</code>) o simplemente leer el valor (<code class="methodname">externalSubset</code>, <code class="methodname">internalSubset</code>).</p><p>El siguiente ejemplo establece el tipo de un documento:</p><pre class="programlisting">use XML::LibXML;
my $doc = XML::LibXML::Document-&gt;new;
my $dtd = $doc-&gt;createExternalSubset( "html",
                                          "-//W3C//DTD XHTML 1.0 Transitional//EN",
                                          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
                                        );
print $dtd-&gt;toString;</pre><p>El resultado:</p><pre class="screen">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</pre><p>El método <code class="methodname">createDTD</code> crea un nodo <code class="classname">XML::LibXML::Dtd</code> sin prejuzgar si es interno o externo. El uso posterior de uno de los métodos <code class="methodname">setExternalSubset</code> o <code class="methodname">setInternalSubset</code> nos permite precisarlo posteriormente, sustituyendo a <code class="methodname">adoptNode</code> o <code class="methodname">importNode</code>:</p><pre class="programlisting">my $dtd = $doc-&gt;createDTD( "html",
                                "-//W3C//DTD XHTML 1.0 Transitional//EN",
                                "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
                              );
$doc-&gt;setInternalSubset( $dtd);</pre><p>Al método <code class="methodname">insertProcessingInstruction</code>, alternativa a <code class="methodname">createProcessingInstruction</code> nos referiremos al tratar las instrucciones de procesamiento</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2467949"></a><code class="classname"><code class="classname">Element</code></code></h4></div></div></div><p>Los nodos Element son contenedores de otros nodos. En el modelo DOM son los encargados de crear las ramas del árbol como posición intermedia entre los nodos raíz (Document o DocumentFragment) y los nodos con información final.</p><div class="table"><a name="id2467967"></a><p class="title"><b>Table 8. Interfaz DOM Element y clase XML::LibXML::Element</b></p><table summary="Interfaz DOM Element y clase XML::LibXML::Element" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><p>Tipo</p></th><th align="left"><p>Nombre</p></th><th align="left"><p>RW</p></th><th align="left"><p>Nivel</p></th><th align="left"><p>Método</p></th></tr></thead><tbody><tr><td align="left"><p>attr</p></td><td align="left"><p>schemaTypeInfo</p></td><td align="left"><p>R</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>tagName</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getAttribute</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>getAttribute</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getAttributeNode</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>getAttributeNode</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getAttributeNodeNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>getAttributeNodeNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getAttributeNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>getAttributeNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getElementsByTagName</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>getElementsByTagName</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>getElementsByTagNameNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>getElementsByTagNameNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>hasAttribute</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>hasAttribute</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>hasAttributeNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>hasAttributeNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>removeAttribute</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>removeAttribute</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>removeAttributeNode</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>removeAttributeNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>removeAttributeNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setAttribute</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td align="left"><p>setAttribute</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setAttributeNode</p></td><td align="left"><p></p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setAttributeNodeNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setAttributeNS</p></td><td align="left"><p></p></td><td align="left"><p>2</p></td><td align="left"><p>setAttributeNS</p></td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setIdAttribute</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setIdAttributeNode</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>oper</p></td><td align="left"><p>setIdAttributeNS</p></td><td align="left"><p></p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>appendText | appendTextNode</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>appendWellBalancedChunk | appendChild</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>appendTextChild</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>getChildrenByTagName</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>getChildrenByTagNameNS</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>getElementsByLocalName</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>new</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>setNamespace</p></td></tr></tbody></table></div><p>DOM incluye en el interfaz la propiedad <code class="varname">tagName</code>, que no está implementada en <code class="classname">XML::LibXML::Element</code>. En su lugar acudiremos a los métodos <code class="methodname">nodeName</code>, <code class="methodname">setNodeName</code> o <code class="methodname">localname</code> que heredamos de la clase padre, <code class="classname">XML::LibXML::Node</code>.</p><p><code class="classname">XML::LibXML</code> incluye extensiones al estandard para añadir nodos hijo a un objeto <span class="type">Element</span>. El método <code class="methodname">appendWellBalancedChunk</code> -o su alias <code class="methodname">appendChild</code>- permite incluir un fragmento balanceado, es decir una sucesión cualquiera de nodos hijo, sin encuadrarse en un elemento. Puesto que el procesador puede tratar también textos balanceados, podemos obtener esos fragmentos directamente, y añadirlos a un nodo <code class="classname">Element</code>, de esta manera:</p><pre class="programlisting">my $element = XML::LibXML::Element-&gt;new( $name )
my $fragment = $parser-&gt;parse_xml_chunk( $chunk );
$element-&gt;appendChild( $fragment );</pre><p>El método <code class="methodname">appendText</code> - o su alias <code class="methodname">appendTextNode</code> - añade un nodo texto a un elemento, que puede contener otros nodos hijos. El método <code class="methodname">appendTextChild</code> en cambio crea un elemento con un único hijo, un nodo texto. </p><p>Otros métodos extienden la posibilidad de buscar conjuntos de nodos dentro del elemento, que en DOM queda reducida a la búsqueda de nodos con un determinado nombre, ya sea simple (<code class="methodname">getElementsByTagName</code>) o con espacio de nombres (<code class="methodname">getElementsByTagNameNS</code>). El método <code class="methodname">getElementsByLocalName</code> permite buscar elementos que contengan un determinado nombre local, no sólo el conjunto nombre local + espacio de nombres que permite <code class="methodname">getElementsByTagNameNS</code>. Por último, los métodos <code class="methodname">getChildrenByTagName</code> y <code class="methodname">getChildrenByTagNameNS</code> listan los nodos hijo con igual nombre de etiqueta.</p><p>El método <code class="methodname">setNameSpace</code> permite añadir espacios de nombres al nodo <span class="type">Element</span>. Según los parámetros recibidos, se instalará un espacio de nombres adicional, a añadir a la lista de los ya existentes, o será el espacio de nombres por defecto del elemento.</p><p>DOM prevee la creación de nodos <span class="type">Element</span> desde Document. <code class="classname">LibXML::XML</code> en cambio nos permite crear nodos <code class="classname">LibXML::XML::Element</code> independientes, gracias al método <code class="methodname">new</code>. Estos nodos están desligados mientras no los insertemos en un árbol, y por defecto quedan adscritos a un nodo <code class="classname">LibXML::XML::DocumentFragment</code> implícito.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2468837"></a>Interfaces de texto</h4></div></div></div><p>DOM modela los interfaces de texto desde un interfaz común, <code class="interfacename">CharacterData</code>, del que heredan los interfaces <code class="interfacename">Text</code> y <code class="interfacename">Comment</code>. A su vez el interfaz <code class="interfacename">Text</code> sirve de base para <code class="interfacename">CDATASection</code>.</p><div class="mediaobject"><img src="CharacterData.png" alt="Los interfaces de texto de DOM"></div><p><code class="classname">XML::LibXML</code> prescinde del interfaz <code class="interfacename">CharacterDat</code>a y concentra todos los métodos en <code class="classname">LibXML::XML::Text</code>. Las clases <code class="classname">LibXML::XML::Comment</code> y <code class="classname">LibXML::XML::CDATASection</code> heredan los métodos de <code class="classname">LibXML::XML::Text</code> y no poseen métodos propios.</p><div class="mediaobject"><img src="Text.png" alt="Las clases de texto de XML::LibXML"></div><p>Por lo demás, <code class="classname">LibXML::XML::Text</code> implementa prácticamente todo el interfaz <code class="interfacename">CharacterData</code>. Pero como las operaciones de subcadenas son limitadas en DOM, añade extensiones para ellas.</p><p>Las operaciones DOM <code class="methodname">replaceData</code> y <code class="methodname">deleteData</code> (y sus correspondientes métodos <code class="classname">XML::LibXML::Text</code>) cambian o borran subcadenas, indicando la posición de inicio y la longitud. Los métodos <code class="methodname">replaceDataString</code> y <code class="methodname">deleteDataString</code> parten de subcadenas conocidas, sustituyéndolas o eliminándolas.</p><pre class="programlisting">$text-&gt;deleteDataString($remstring, $flag);
$text-&gt;replaceDataString($old, $new, $flag);</pre><p>El parámetro final es un indicador de si la operación se realizará una sólo vez (con valor 0) o en todas las ocurrencias (con valor 1).</p><p>Por último, el método r<code class="methodname">eplaceDataRegEx</code> permite la sustitución de una cadena mediante un patrón de expresiones regulares.</p><p>Como en otros nodos intermedios o finales, <code class="classname">LibXML::XML</code> permite extender las posibilidades de DOM creando nodos <code class="classname">LibXML::XML::Text</code> invocando la clase directamente con el método <code class="methodname">new</code>, sin necesidad de hacerlo desde <code class="classname">LibXML::XML::Document</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2469025"></a><code class="classname">PI</code> (<code class="interfacename">ProcessingInstruction</code>)</h4></div></div></div><p>DOM define este interfaz para instrucciones de procesamiento con dos únicas propiedades, para indicar la marca o identificador de enlace (la primera palabra) y un texto que le sigue.</p><div class="table"><a name="id2469044"></a><p class="title"><b>Table 9. Interfaz DOM ProcessingInstruction y clase XML::LibXML::PI</b></p><table summary="Interfaz DOM ProcessingInstruction y clase XML::LibXML::PI" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><p>Tipo</p></th><th align="left"><p>Nombre</p></th><th align="left"><p>RW</p></th><th align="left"><p>Nivel</p></th><th align="left"><p>Método</p></th></tr></thead><tbody><tr><td align="left"><p>attr</p></td><td align="left"><p>data</p></td><td align="left"><p>RW</p></td><td align="left"><p>1</p></td><td align="left"><p>setData</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>target</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr></tbody></table></div><p>El texto puede ser escrito mediante el método <code class="methodname">setData</code>, mientras que para la lectura utilizaremos el método <code class="methodname">getData</code> que provee la clase superior, <code class="classname">XML::LibXML::Node</code>. La marca es accesible mediante los métodos <code class="methodname">nodeName</code> y <code class="methodname">setNodeName</code> de <code class="classname">XML::LibXML::Node</code> o al tiempo de creación del nodo.</p><p>La creación de una instrucción de procesamiento, siguiendo los métodos DOM, implica tres pasos: Crearla, escribir el texto que contiene y añadirla al árbol:</p><pre class="programlisting">my $pi = $dom-&gt;createProcessingInstruction("abc");
$pi-&gt;setData(foo=&gt;'bar', foobar=&gt;'foobar');
$dom-&gt;appendChild( $pi );</pre><p><code class="classname">XML::LibXML::Document</code> nos provee del método alternativo <code class="methodname">insertProcessingInstruction</code> para hacerlo todo en un paso:</p><pre class="programlisting">$dom-&gt;insertProcessingInstruction("abc",'foo="bar" foobar="foobar"');</pre><p>que dará el mismo resultado que el código de arriba:</p><pre class="screen">&lt;?abc foo="bar" foobar="foobar"?&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2469236"></a><code class="classname">Attr</code> (<code class="interfacename">Attribute</code>)</h4></div></div></div><p><code class="classname">XML::LibXML::Attr</code> implementa el interfaz <code class="interfacename">Attribute</code> de DOM.</p><div class="table"><a name="id2469256"></a><p class="title"><b>Table 10. Interfaz DOM Attribute y clase XML::LibXML::Attr</b></p><table summary="Interfaz DOM Attribute y clase XML::LibXML::Attr" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><p>Tipo</p></th><th align="left"><p>Nombre</p></th><th align="left"><p>RW</p></th><th align="left"><p>Nivel</p></th><th align="left"><p>Método</p></th></tr></thead><tbody><tr><td align="left"><p>attr</p></td><td align="left"><p>isId</p></td><td align="left"><p>R</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>name</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>ownerElement</p></td><td align="left"><p>R</p></td><td align="left"><p>2</p></td><td align="left"><p>getOwnerElement</p></td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>schemaTypeInfo</p></td><td align="left"><p>R</p></td><td align="left"><p>3</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>specified</p></td><td align="left"><p>R</p></td><td align="left"><p>1</p></td><td class="auto-generated"> </td></tr><tr><td align="left"><p>attr</p></td><td align="left"><p>value</p></td><td align="left"><p>RW</p></td><td align="left"><p>1</p></td><td align="left"><p>value |getValue - setValue</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>new</p></td></tr><tr><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p></p></td><td align="left"><p>setNamespace</p></td></tr></tbody></table></div><p>En esta clase tampoco hay una implementación de la propiedad <code class="varname">Name</code> de DOM, y acudiremos a los métodos <code class="methodname">nodeName</code>, <code class="methodname">setNodeName</code> o <code class="methodname">localname</code> que heredamos de XML::LibXML::Node.</p><p>El método <code class="methodname">setNameSpace</code> extiende el interfaz DOM para permitir colocar el atributo en un espacio de nombres.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2469535"></a><code class="classname">Dtd</code></h4></div></div></div><p>La clase <code class="classname">XML::LibXML::Dtd</code> incluye un procesador para documentos DTD, como la clase <code class="classname">LibXML::XML</code> ofrece un procesador para documentos XML. El procesamiento con esta clase devuelve un objeto especial, de esta clase.</p><p>Los nodos <span class="type">Dtd</span> se corresponden -más bien sustituyen- al interfaz DOM <code class="interfacename">DocumentType</code>, que es hijo (en una sola ocurrencia) de un nodo <code class="interfacename">Document</code>. <code class="classname">XML::LibXML::Dtd</code> no obstante no implementa los métodos de <code class="interfacename">DocumentType</code>. Tan sólo posee los métodos que hereda de <code class="classname">XML::LibXML::Node</code>, aunque dada la naturaleza de los DTDs no todos los métodos están disponibles.</p><p>Puesto que los DTDs no soportan espacios de nombres, los métodos de <code class="classname">XML::LibXML::Node</code> que se refieren a ellos no están soportados en este tipo de nodo.</p><p>Sí en cambio soportan todos los métodos de <code class="classname">XML::LibXML::Node</code> referentes a los nodos que se encuentran incluidos en él, que son objetos <span class="type">Node</span> de los tipos 15 a 18 en la tabla de <span class="type">NodeType</span> de libxml2 que veíamos arriba, como las operaciones de inserción, eliminación o búsqueda.</p><p>Como hemos visto, la clase <code class="classname">XML::LibXML::Document</code> también manipula objetos <code class="classname">XML::LibXML::Dtd</code>, pero los creados mediante los métodos <code class="methodname">new</code> o <code class="methodname">parse_string</code> de <code class="classname">XML::LibXML::Dtd</code> son procesados y expandidos y se puede acceder a sus nodos componentes; los creados mediante <code class="methodname">createDTD</code> o <code class="methodname">createInternalSubset</code> de <code class="classname">XML::LibXML::Document</code> son también procesados, y pueden utilizarse para validación, pero sus componentes no son accesibles desde los métodos de <code class="classname">XML::LibXML::Node</code>; los creados mediante el método <code class="methodname">createExternalSubset</code> de <code class="classname">XML::LibXML::Document</code> no son procesados, simplemente se crea el nodo y se incluye la uri en el mismo.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2469678"></a><code class="classname">Namespace</code></h4></div></div></div><p><code class="classname">XML::LibXML</code> altera el esquema DOM introduciendo una irregularidad, una clase adicional, <code class="classname">XML::LibXML::Namespace</code>, independiente, que no hereda de <code class="classname">XML::LibXML::Node</code>. Desde un punto de vista general no tiene sentido explicar el documento XML como un conjunto de nodos y objetos <span class="type">Namespace</span>, desligados; por tanto ha de verse en realidad como herramienta práctica para utilizar los espacios de nombres.</p><p><code class="classname">XML::LibXML</code> concibe los objetos <span class="type">Namespace</span> de manera similar al de los nodos <code class="classname">XML::LibXML::Attribute</code>: Un nodo, en especial un nodo <code class="classname">XML::LibXML::Element</code>, puede contener nodos <code class="classname">XML::LibXML::Attribute</code> y objetos <span class="type">Namespace</span>.</p><p>XML::LibXML modela los espacios de nombres como una clase con dos propiedades: el identificador, y la uri correspondiente. </p><p>El identificador a su vez se compone de la marca de los espacios de nombres -la cadena constante <code class="constant">xmlns</code>- y un prefijo. Para acceder al primero se provee del método <code class="methodname">prefix</code>, y al segundo, el método <code class="methodname">name</code> o sus alias <code class="methodname">getName</code> y <code class="methodname">getLocalName</code>. Al identificador completo podemos acceder mediante el método <code class="methodname">nodeName</code> o su alias <code class="methodname">getNodeName</code>.</p><p>A la uri se accede mediante el método <code class="methodname">value</code>, o su alias <code class="methodname">getData</code>.</p><p>Para crear los objetos contamos con el método <code class="methodname">new</code>. También obtenemos objetos <code class="classname">XML::LibXML::Namespace</code>, en este caso arreglos de objetos, con los métodos <code class="methodname">findnodes</code>, de <code class="classname">XML::LibXML::Element</code> y <code class="methodname">getNamespaces</code>, de <code class="classname">XML::LibXML::Node</code>.</p><p>Este código de ejemplo sirve de test básico para los métodos de la clase:</p><pre class="programlisting">use XML::LibXML;
my $string = '&lt;a xmlns:b="http://myNamespace.com"&gt;&lt;b:c/&gt;&lt;/a&gt;';
my $parser = XML::LibXML-&gt;new();
my $document = $parser-&gt;parse_string($string);
my @ns=$document-&gt;firstChild-&gt;getNamespaces();
foreach (@ns){
	print $_-&gt;prefix, "\n";
	print $_-&gt;nodeName, "\n";
	print $_-&gt;getLocalName, "\n";
	print $_-&gt;value, "\n";
}</pre><p>El arreglo obviamente sólo contiene un espacio de nombres:</p><pre class="screen">xmlns
xmlns:b
b
http://myNamespace.com</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2469843"></a>Salida</h3></div></div></div><p>La clase <code class="classname">XML::LibXML::Node</code> incorpora varios métodos para la salida de datos. El más importante es <code class="methodname">toString</code>, que heredarán todas las otras clases DOM. Se puede invocar con un alias, <code class="methodname">serialize</code>.</p><p>Este método genera en la salida estandard un texto XML correspondiente a un objeto DOM. En principio tiene sentido para los nodos <span class="type">Document</span>, pero se provee de una mayor precisión, y al hallarse en este nivel podemos volcar nodos concretos de todo tipo.</p><p>Un parámetro (opcional) pasa un indicador acerca de si el documento debe ser formateado con identado y saltos de línea (un número mayor de 1), con identado (1) o con los elementos originales (0, por defecto);</p><p>Un segundo parámetro (también opcional) hace que el texto XML se genere en la codificación original del documento, y no en UTF-8, que es el formato interno que utiliza Perl para los datos. Esto es válido a partir de Perl 5.006. Obviamente invocar esta opción ha de estar en consonancia con el uso posterior de los datos, porque Perl seguirá empeñado en utilizar la cadena resultante como UTF-8, salvo que le digamos lo contrario.</p><p>las clases <code class="classname">XML::LibXML::Document</code> y <code class="classname">XML::LibXML::DocumentFragment</code> realizan sus propias variantes del método; en ellas no está disponible este segundo parámetro de respeto de la codificación original.</p><p>La salida que ofrece el método <code class="methodname">toString</code> depende también de algunas variables globales del procesador: </p><div class="itemizedlist"><ul type="disc"><li><p><code class="varname">skipXMLDeclaration</code>, si está activada hace que no se vuelque la declaración XML.</p></li><li><p><code class="varname">skipDTD</code>, si está activada hace que no se vuelquen las definiciones internas de tipos.</p></li><li><p><code class="varname">setTagCompression</code>, si está activada los elementos nulos serán expandidos con etiqueta inicial y final.</p></li></ul></div><p>No hay métodos para ellas, o sea que las debemos de utilizar directamente:</p><pre class="programlisting">local $XML::LibXML::skipXMLDeclaration=1;</pre><p>Y se trata de variables globales, que afectan al procesador DOM y a todos los documentos que utilicen este objeto.</p><p>Otro método de XML::LibXML::Node para la salida es <code class="methodname">string_value</code>. En este caso se vuelcan tan sólo los elementos textuales del nodo.</p><p>XML::LibXML::Document posee un método de salida con identado automático, pensado para los documentos HTML, <code class="methodname">toStringHTML</code>, al que también podemos invocar por su alias <code class="methodname">serialize_html</code>.</p><p>XML::LibXML::Node provee también de un método para un volcado canónico del nodo, <code class="methodname">toStringC14N</code>, con su alias <code class="methodname">serialize_c14n</code>. La canonización, definida en el <a href="http://www.ietf.org/rfc/rfc3076.txt" target="_top">RFC 3076</a> es el formateado del texto XML siguiendo unas reglas concretas (remover la declaración del DTD, valores normalizados en los atributos, eliminación de espacios en blanco extras, etc..).</p><p>El método propuesto por <code class="classname">XML::LibXML::Node</code> para la canononización de nodos XML permite dos parámetros para alterar su conducta. El primero es una marca indicadora de si se vuelcan los comentarios o no. Como parámetro adicional podemos indicar una expresión XPath que limite el alcance del volcado.</p><p>Este ejemplo nos permitirá un primer contacto con las diversas posibilidades de la salida de un nodo <code class="classname">XML::LibXML::Document</code>:</p><pre class="programlisting">use XML::LibXML;
my $parser = XML::LibXML-&gt;new();
my $doc = $parser-&gt;parse_string('&lt;html&gt;&lt;body&gt;&lt;p&gt;hola&lt;/p&gt;&lt;p&gt;&lt;!-- típico ejemplo --&gt;mundo&lt;/p&gt;&lt;p/&gt;&lt;/body&gt;&lt;/html&gt;');
print "--Salida de toString (0)--:\n" . $doc-&gt;toString(0);
print "--Salida de toString (1)--:\n" . $doc-&gt;toString(1);
print "--Salida de toString (2)--:\n" . $doc-&gt;toString(2);
print "--Salida de string_value:--\n" . $doc-&gt;string_value() . "\n";
print "--Salida de toStringHTML():--\n" . $doc-&gt;toStringHTML();
print "--Salida de toStringC14N():--\n" . $doc-&gt;toStringC14N(). "\n";
print "--Salida de toStringC14N(1):--\n" . $doc-&gt;toStringC14N(1). "\n";
print "--Salida de toStringC14N(1,'//p'):--\n" . $doc-&gt;toStringC14N(1,"//p"). "\n";
local $XML::LibXML::skipXMLDeclaration=1;
$doc = $parser-&gt;parse_string('&lt;html&gt;&lt;body&gt;&lt;p&gt;hola&lt;/p&gt;&lt;p&gt;&lt;!-- típico ejemplo --&gt;mundo&lt;/p&gt;&lt;p/&gt;&lt;/body&gt;&lt;/html&gt;');
print "--Salida de toString (0) con skipXMLDeclaration--:\n" . $doc-&gt;toString . "\n";
local $XML::LibXML::setTagCompression = 1;
$doc = $parser-&gt;parse_string('&lt;html&gt;&lt;body&gt;&lt;p&gt;hola&lt;/p&gt;&lt;p&gt;&lt;!-- típico ejemplo --&gt;mundo&lt;/p&gt;&lt;p/&gt;&lt;/body&gt;&lt;/html&gt;');
print "--Salida de toString (0) con setTagCompression--:\n" . $doc-&gt;toString . "\n";</pre><p>Obsérvese que algunos de los formateos no incluyen un salto de línea adicional al final, y hemos tenido que colocarlas nosotros para mayor claridad.</p><pre class="screen">--Salida de toString (0)--:
&lt;?xml version="1.0"?&gt;
&lt;html&gt;&lt;body&gt;&lt;p&gt;hola&lt;/p&gt;&lt;p&gt;&lt;!-- típico ejemplo --&gt;mundo&lt;/p&gt;&lt;p/&gt;&lt;/body&gt;&lt;/html&gt;
--Salida de toString (1)--:
&lt;?xml version="1.0"?&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;hola&lt;/p&gt;
    &lt;p&gt;&lt;!-- típico ejemplo --&gt;mundo&lt;/p&gt;
    &lt;p/&gt;
  &lt;/body&gt;
&lt;/html&gt;
--Salida de toString (2)--:
&lt;?xml version="1.0"?&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;
hola
    &lt;/p&gt;
    &lt;p&gt;
&lt;!-- típico ejemplo --&gt;
mundo
    &lt;/p&gt;
    &lt;p/&gt;
  &lt;/body&gt;
&lt;/html&gt;
--Salida de string_value:--
holamundo
--Salida de toStringHTML():--
&lt;html&gt;&lt;body&gt;
&lt;p&gt;hola&lt;/p&gt;
&lt;p&gt;&lt;!-- t&amp;iacute;pico ejemplo --&gt;mundo&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
--Salida de toStringC14N():--
&lt;html&gt;&lt;body&gt;&lt;p&gt;hola&lt;/p&gt;&lt;p&gt;mundo&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
--Salida de toStringC14N(1):--
&lt;html&gt;&lt;body&gt;&lt;p&gt;hola&lt;/p&gt;&lt;p&gt;&lt;!-- típico ejemplo --&gt;mundo&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;--Salida de toStringC14N(1,'//p'):--
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
--Salida de toString (0) con skipXMLDeclaration--:
&lt;html&gt;&lt;body&gt;&lt;p&gt;hola&lt;/p&gt;&lt;p&gt;&lt;!-- típico ejemplo --&gt;mundo&lt;/p&gt;&lt;p/&gt;&lt;/body&gt;&lt;/html&gt;
--Salida de toString (0) con setTagCompression--:
&lt;html&gt;&lt;body&gt;&lt;p&gt;hola&lt;/p&gt;&lt;p&gt;&lt;!-- típico ejemplo --&gt;mundo&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre><p>Los métodos anteriores devuelven cadenas de caracteres en escalares de Perl. Es posible también volcar la salida directamente a un archivo, con el método <code class="methodname">toFile</code> de <code class="classname">XML::LibXML::Document</code>. Éste presenta prestaciones similares al método de la misma clase, <code class="methodname">toString</code>, y admite también una marca de formateado con valores similares.</p><p>Es posible también volcar los resultados a un filehandle, y con ello encadenarlo a otros procesos del sistema, con el método <code class="methodname">toFH</code>, con el mismo sistema de formateado.</p><p>Por ejemplo, para emular la orden print de Perl, con una salida formatetada de tipo 2 (con salto de línea entre nodos):</p><pre class="programlisting">$outref=*STDOUT{IO};
$doc-&gt;toFH($outref,2);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2470161"></a>XPath</h3></div></div></div><p>Las funciones <a href="http://www.w3.org/TR/xpath" target="_top">XPath</a> residen en la clase <code class="classname">XML::LibXML::Node</code>, es decir, están disponibles para todo el árbol DOM.</p><p>La implementación de XPath en <code class="classname">XML::LibXML</code> es muy simple de usar, y básicamente es accesible desde los métodos <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Node.pod#findnodes" target="_top"><code class="methodname">findnodes</code></a> y <a href="http://search.cpan.org/~phish/XML-LibXML/lib/XML/LibXML/Node.pod#find" target="_top"><code class="methodname">find</code></a>.</p><p>El primero admite expresiones XPath que representan objetos DOM, y en contexto de arreglo devuelve una matriz con los nodos que cumplen la condición expresada; en contexto escalar devuelve un objeto <code class="classname">XML::LibXML::NodeList</code>.</p><pre class="programlisting">  my @nodes = $node-&gt;findnodes( "//p");
  my $nodelist = $node-&gt;findnodes( "//p");
</pre><p>El segundo  admite cualquier expresión XPath (y por tanto cualquier función XPath). En consonancia con una búsqueda más abierta, tiene una salida variada, devolviendo colecciones de nodos, objetos DOM, u objetos de las clases <a href="http://search.cpan.org/perldoc?XML::LibXML::Boolean" target="_top"><code class="classname">XML::LibXML::Boolean</code></a>, <a href="http://search.cpan.org/perldoc?XML::LibXML::Literal" target="_top"><code class="classname">XML::LibXML::Literal</code></a> o <a href="http://search.cpan.org/perldoc?XML::LibXML::Number" target="_top"><code class="classname">XML::LibXML::Number</code></a>.</p><p>En una búsqueda de nodos <code class="methodname">findnodes</code> y <code class="methodname">find</code> son equivalentes:</p><pre class="programlisting">my $nodelist = $doc-&gt;findnodes( "//b");
my $nodelist = $doc-&gt;find( "//b");</pre><p>Pero si la expresión XPath es una función numérica devuelve objetos <code class="classname">XML::LibXML::Number</code>:</p><pre class="programlisting">my $total = $doc-&gt;find( "count(//p)" );</pre><p>Con funciones de cadena devuelve objetos <code class="classname">XML::LibXML::Literal</code></p><pre class="programlisting">my $literal = $doc-&gt;find( "string(//b)");</pre><p>Y con funciones booleanas devuelve objetos <code class="classname">XML::LibXML::Boolean</code></p><pre class="programlisting">my $esta = $doc-&gt;find( "contains(//b, 'U')");</pre><p>Una tercera función XPath en <code class="classname">XML::LibXML::Node</code>, <code class="methodname">findvalue</code> retorna el valor literal del resultado. Es el equivalente del método <code class="methodname">to_literal</code> aplicado al resultado de <code class="methodname">find</code>.</p><p>Las clases XPath disponibles son:</p><div class="itemizedlist"><ul type="disc"><li><p><b><code class="classname">XML::LibXML::Number</code>. </b></p><p>La clase sólo admite dos métodos, <code class="methodname">new</code> y <code class="methodname">value</code>; el primero crea un objeto de esta clase y le asigna un valor y el segundo devuelve ese valor:</p><pre class="programlisting">my $num=XML::LibXML::Number-&gt;new(9);
print $num-&gt;value;</pre></li><li><p><b><code class="classname">XML::LibXML::Boolean</code>. </b></p><p>Los métodos <code class="methodname">True</code> y <code class="methodname">False</code> crean los objetos de esta clase. El método <code class="methodname">value</code> devuelve el valor booleano del objeto, mientras un método adicional, <code class="methodname">to_literal</code> devuelve la cadena <code class="constant">true</code> o <code class="constant">false</code> correspondiente a este valor.</p><pre class="programlisting">my $bool=XML::LibXML::Boolean-&gt;True;
if ($bool-&gt;value) {
	print $bool-&gt;to_literal;
}</pre></li><li><p><b><code class="classname">XML::LibXML::Literal</code>. </b></p><p>La clase admite como las anteriores métodos de creación y lectura del valor, <code class="methodname">new</code>, <code class="methodname">value</code>:</p><pre class="programlisting">my $literal=XML::LibXML::Literal&gt;new("hello world");
print $literal&gt;value;</pre><p>Y un método adicional, <code class="methodname">cmp</code>, que permite comparar el valor almacenado con un escalar Perl o una cadena de caracteres:</p><pre class="programlisting">my $literal=XML::LibXML::Literal-&gt;new("hello world");
print $literal-&gt;cmp("hello world");</pre><p>Equivale al operador Perl <code class="literal">cmp</code> comparando el resultado de <code class="methodname">XML::LibXML::Literal-&gt;value</code> con la cadena:</p><pre class="programlisting">print $literal-&gt;value cmp "hello world";</pre></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2470465"></a>Cómo trabaja</h2></div></div></div><p>Los diversos módulos Perl que se incluyen en la distribución de <a href="http://search.cpan.org/perldoc?XML::LibXML" target="_top"><code class="classname">XML::LibXML</code></a> implementan algunos métodos propios para organizar el trabajo, sobre todo en lo referente a la entrada y la salida, pero la tarea más pesada la realiza la librería <a href="http://xmlsoft.org/" target="_top">libxml2</a>, que se encarga del procesamiento en si. El paso de información entre el los módulos Perl y la librería la realiza el archivo <code class="filename">LibXML.xs</code>, un código escrito en <a href="http://www.perl.com/doc/manual/html/pod/perlxs.html" target="_top">xs</a>, que es básicamente un lenguaje de macros para invocar el <a href="http://www.perl.com/doc/manual/html/pod/perlguts.html" target="_top">API C de Perl</a>. Algunas funciones auxiliares, por ejemplo las de conversión de tipos, se encuentran en otro archivo, <code class="filename">perl-libxml-mm.c</code>.</p><p>Veamos un ejemplo, en este caso quizá el más reducido de los posibles usos de XML::LibXML:</p><pre class="programlisting">#!/usr/bin/perl
use XML::LibXML;
my $parser = XML::LibXML-&gt;new();
my $source = $parser-&gt;parse_file('hola.xml');
print $source-&gt;toString;</pre><p>El código anterior imprimirá casi exactamente el mismo texto de la entrada. De hecho también podemos ver en acción a libxml2 de manera similar si utilizamos la utilidad <span><strong class="command">xmllint</strong></span>, que se incluye en la distribución de libxml2:</p><pre class="programlisting">xmllint hola.xml</pre><p>En nuestro ejemplo Perl, el método <code class="methodname">new</code> crea una instancia del procesador; el método <code class="methodname">parse_file</code> lleva a cabo el procesado del archivo de entrada, es decir la transformación del texto XML a una estructura de datos que podrá manipular el procesador; por último, el método <code class="methodname">toString</code> realiza la tarea contraria, es decir construye un texto XML a partir de la estructura de datos, y la vuelca a la salida estándard. Antes podremos modificar el comportamiento del procesador, y, una vez obtenida, podremos utilizar la información haciendo selecciones o transformaciones, pero el esqueleto del trabajo del módulo ya está presente en este sencillo ejemplo.</p><div class="itemizedlist"><ul type="disc"><li><p><b>El método <code class="methodname">new</code>. </b></p><p>El método <code class="methodname">new</code><sup>[<a name="id2470605" href="#ftn.id2470605">10</a>]</sup> se encarga de crear la instancia de la clase. Éste devuelve un objeto <code class="classname">XML::LibXML</code>, que en esta fase temprana consta tan sólo de una referencia a un hash que incluirá las preferencias de procesado y un escalar con el nombre de la clase:</p><pre class="programlisting">119    my $self = bless \%options, $class;
124    return $self;</pre><p>Los posteriores métodos que habilitan o deshabilitan opciones irán llenando este hash <code class="varname">%options</code> con pares clave-valor que representan las diversas opciones de procesado. Por defecto el método <code class="methodname">new</code><sup>[<a name="id2470641" href="#ftn.id2470641">11</a>]</sup> ya nos habilita una opción, XML_LIBXML_KEEP_BLANKS.</p><p>Así si volcamos el objeto <code class="classname">XML::LibXML</code>:</p><pre class="programlisting">print Dumper $parser;</pre><p>obtenemos la configuración del procesador:</p><pre class="screen">$VAR1 = bless( {
                 'XML_LIBXML_KEEP_BLANKS' =&gt; 1,
               }, 'XML::LibXML' );</pre><p>Anotemos que el método <code class="methodname">new</code>  en realidad es más complejo, porque aunque se utiliza sin argumentos, y las opciones se especifican mediante los métodos correspondientes, puede recibir como parámetros las opciones directamente, como pares clave valor (posibilidad no indicada en la documentación); es por ello que el método <code class="methodname">new</code> ha de hacer algunas previsiones adicionales, puesto que no todas las opciones son simplemente flags; así, la opción <code class="option">catalog</code>, correspondiene al método <code class="methodname">load_catalog</code> ha de invocar directamente una función de libxml2 para que proceda a la carga del catálogo indicado.</p></li><li><p><b>El método <code class="methodname">parse_file</code>. </b></p><p>El método <code class="methodname">parse_file</code><sup>[<a name="id2470720" href="#ftn.id2470720">12</a>]</sup>, se encarga de dircernir entre los dos métodos de procesamiento de libxml2, el método DOM, por defecto, o su alternativa SAX. Si no hemos indicado nada se utiliza el primero, y el tratamiento básico es éste:</p><pre class="programlisting">435	eval { $result = $self-&gt;_parse_file(@_); };
442	$result = $self-&gt;_auto_expand( $result );
445	return $result;</pre><p>Es decir, llama bajo eval, para evitar que el programa aborte por un fallo en el procesado, a la función <code class="function">_parse_file</code>, al que le pasa todos los argumentos que recibe, y posteriormente a la función <code class="function">_auto_expand</code>.</p><p>El flujo principal de la función <code class="function">_parse_file</code><sup>[<a name="id2470761" href="#ftn.id2470761">13</a>]</sup>, es como sigue:</p><pre class="programlisting">1232 HV * real_obj;
1235 xmlDocPtr real_doc;

1249 xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt(filename);
1267 xmlParseDocument(ctxt);
1273 real_doc = ctxt-&gt;myDoc;
1285 RETVAL = LibXML_NodeToSv( real_obj, (xmlNodePtr) real_doc );</pre><p>Es decir, que el núcleo de un programa C equivalente, para nuestro ejemplo, sería:</p><pre class="programlisting">xmlDocPtr real_doc;
xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt(filename);
xmlParseDocument(ctxt);
real_doc = ctxt-&gt;myDoc;</pre><p>La función <a href="http://xmlsoft.org/html/libxml-parserInternals.html#xmlCreateFileParserCtxt" target="_top"><code class="function">xmlCreateFileParserCtxt</code></a> crea el contexto del procesador para el archivo <code class="filename">filename</code>, o sea que devuelve un puntero, <code class="varname">ctxt</code>, del tipo <a href="http://xmlsoft.org/wiki/libxml-tree.html#xmlParserCtxtPtr" target="_top"><span class="type">xmlParserCtxtPtr</span></a>, a una estructura <a href="http://xmlsoft.org/wiki/libxml-tree.html#xmlParserCtxt" target="_top"><span class="structname">xmlParserCtxt</span></a> que contiene ese contexto. El procesado en sí lo efectúa la función <a href="http://xmlsoft.org/html/libxml-parser.html#xmlParseDocument" target="_top"><code class="function">xmlParseDocument</code></a>, que recibe como argumento el puntero anterior, y que poblará la estructura <span class="structname">xmlParserCtxt</span> con el resultado; más concretamente nos interesa una parte de éste, la estructura, del tipo  <a href="http://xmlsoft.org/wiki/libxml-tree.html#xmlDoc" target="_top"><span class="structname">xmlDoc</span></a>, que recoge los datos del árbol DOM del documento de entrada, a la que accederemos desde el puntero <em class="structfield"><code>ctxt-&gt;myDoc</code></em>, del tipo <a href="http://xmlsoft.org/wiki/libxml-tree.html#xmlDocPtr" target="_top"><span class="type">xmlDocPtr</span></a>.</p></li><li><p><b>El método <code class="methodname">toString</code>. </b></p><p>El método <code class="methodname">toString</code><sup>[<a name="id2470880" href="#ftn.id2470880">14</a>]</sup> es el responsable de realizar el trabajo contrario al procesado, es decir, producir un texto XML a partir de la estructura de datos que utiliza libxml2.</p><p>El código relevante de la función:</p><pre class="programlisting">695 $retval =  $self-&gt;_toString($flag);</pre>

	invoca a la función <code class="function">xmlCreateFileParserCtxt</code><sup>[<a name="id2470901" href="#ftn.id2470901">15</a>]</sup>, que es la que hace en realidad todo el trabajo: 

	<pre class="programlisting">2206 xmlDocPtr self
2209 xmlChar *result=NULL;
2232 xmlDocDumpMemory(self, &amp;result, &amp;len);
2260 RETVAL = C2Sv( result, self-&gt;encoding );</pre><p>La función <a href="http://xmlsoft.org/html/libxml-tree.html#xmlDocDumpMemory" target="_top"><code class="function">xmlDocDumpMemory</code></a>   vuelca el contenido de la estructura <span class="structname">xmlDoc</span> señalada por el puntero de tipo <span class="type">xmlDocPtr</span> <code class="varname">self</code> a <code class="varname">result</code>, un flujo de caracteres (en realidad de caracteres <a href="http://xmlsoft.org/html/libxml-xmlstring.html#xmlChar" target="_top"><span class="type">xmlChar</span></a>, que son del tipo C <span class="type">unsigned char</span>). El resultado posteriormente se convierte al tipo de Perl  <a href="http://www.perl.com/doc/manual/html/pod/perlguts.html#Variables" target="_top"><span class="type">SV</span></a> o sea un escalar , gracias a la función <code class="function">C2Sv</code><sup>[<a name="id2470965" href="#ftn.id2470965">16</a>]</sup>; con esto ya podemos más tarde imprimir el resultado de nuestro ejemplo.</p><p>Si se ha decidido que el resultado sea indentado, se utiliza una función alternativa, <a href="http://xmlsoft.org/html/libxml-tree.html#xmlDocDumpFormatMemory" target="_top"><code class="function">xmlDocDumpFormatMemory</code></a>:</p><pre class="programlisting">2236 xmlDocDumpFormatMemory( self, &amp;result, &amp;len, format );</pre></li></ul></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2408349" href="#id2408349">1</a>] </sup>Líneas 1181-1201 de LibXML.pm (v. 1.102). </p></div><div class="footnote"><p><sup>[<a name="ftn.id2408358" href="#id2408358">2</a>] </sup>Líneas 1203-1220 de LibXML.pm (v. 1.102). </p></div><div class="footnote"><p><sup>[<a name="ftn.id2408390" href="#id2408390">3</a>] </sup>Contenido en lib/XML/libXML/SAX/Parser.pm en la distribución.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2408961" href="#id2408961">4</a>] </sup>Líneas 98-113 de lib/XML/libXML/SAX/Generator.pm (v. 1.4) en la distribución.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2460883" href="#id2460883">5</a>] </sup>143 test, 142 con éxito.</p><p>El error se produjo en el test <a href="http://www.w3.org/MarkUp/Test/HTML401/current/tests/17_7-BF-02" target="_top">17_7-BF-02</a> donde dos formularios tienen sendos elemento textarea de idéntico nombre. El procesador de libxml2 falla al creer que el nombre debe ser único.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2460963" href="#id2460963">6</a>] </sup>Línea 1688 LibXML.xs v 1.178.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2460976" href="#id2460976">7</a>] </sup>Línea 1531 LibXML.xs v1.178.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2462470" href="#id2462470">8</a>] </sup>lineas 222-292 de LibXML.pm.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2462482" href="#id2462482">9</a>] </sup>lineas 619-771 en LibXML.xs v 1.178.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2470605" href="#id2470605">10</a>] </sup>lineas 107-125 de LibXML.pm,v 1.102.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2470641" href="#id2470641">11</a>] </sup>linea 111 de LibXML.pm.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2470720" href="#id2470720">12</a>] </sup>lineas 420-446 de LibXML.pm.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2470761" href="#id2470761">13</a>] </sup>lineas 1225-1295 en LibXML.xs v 1.178.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2470880" href="#id2470880">14</a>] </sup>líneas 679-699 de LibXML.pm.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2470901" href="#id2470901">15</a>] </sup>líneas 2203-2264 de LibXML.xs.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2470965" href="#id2470965">16</a>] </sup>lineas 879-911 de perl-libxml-mm.c, v 1.41.</p></div></div></div></body>
</html>
